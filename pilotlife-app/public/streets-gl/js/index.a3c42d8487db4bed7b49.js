(()=>{(()=>{"use strict";var tt={1674:(A,H,k)=>{class U{static convertCommandsToPoints(e,t,n){const r=[];let s=[0,0];for(let i=0;i<e.length;i++){const a=e[i]&7,l=e[i]>>3;if(a===1)for(let c=0;c<l;c++){i+=2;const d=this.parseCoordinates(e[i-1],e[i],t,n);d[0]+=s[0],d[1]+=s[1],r.push(d),s=d}}return r}static convertCommandsToLineString(e,t,n){const r=[];let s=[],i=[0,0];for(let a=0;a<e.length;a++){const l=e[a]&7,c=e[a]>>3;if(l===1){s=[],r.push(s);for(let d=0;d<c;d++){a+=2;const h=this.parseCoordinates(e[a-1],e[a],t,n);h[0]+=i[0],h[1]+=i[1],s.push(h),i=h}}else if(l===2)for(let d=0;d<c;d++){a+=2;const h=this.parseCoordinates(e[a-1],e[a],t,n);if(h[0]+=i[0],h[1]+=i[1],s.length>0&&this.distance(s[0],h)<.001){const f=s[0];h[0]=f[0],h[1]=f[1]}i=h,s.push(h)}}return r}static convertCommandsToPolygon(e,t,n){const r=[];let s=[],i=[0,0],a=[0,0];for(let l=0;l<e.length;l++){const c=e[l]&7,d=e[l]>>3;if(c===1){s=[],r.push(s);for(let h=0;h<d;h++){l+=2;const f=this.parseCoordinates(e[l-1],e[l],t,n);f[0]+=a[0],f[1]+=a[1],s.push(f),i=f,a=f}}else if(c===2)for(let h=0;h<d;h++){l+=2;const f=this.parseCoordinates(e[l-1],e[l],t,n);f[0]+=a[0],f[1]+=a[1],s.push(f),a=f}else c===7&&s.push([...i])}return r}static parseCoordinates(e,t,n,r){const s=this.zigzagDecode(e)/(n-1),i=this.zigzagDecode(t)/(n-1);return[s*r,i*r]}static zigzagDecode(e){return e>>>1^-(e&1)}static distance(e,t){const n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}}var W=(o=>(o[o.Inner=0]="Inner",o[o.Outer=1]="Outer",o))(W||{}),q=(o=>(o[o.None=0]="None",o[o.Node=1]="Node",o[o.Way=2]="Way",o[o.Relation=3]="Relation",o))(q||{});class de{constructor(e){this.rings=[],this.descriptor=e}addRing(e){if(!de.validateRing(e))throw new Error("Invalid MapBox ring");const n=de.isRingClockwise(e)?W.Outer:W.Inner,r=e.map(([s,i])=>({type:"node",x:s,y:i,rotation:0,osmReference:null,descriptor:null}));this.rings.push({type:n,nodes:r})}getFeatures(){const e=[];for(const t of this.rings)if(t.type===W.Outer)e.push({type:"area",rings:[t],osmReference:{id:0,type:q.None},descriptor:this.descriptor});else{if(!e[e.length-1])throw new Error("Invalid MapBox ring order");e[e.length-1].rings.push(t)}return e}static isRingClockwise(e){let t=0;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1]??e[0];t+=(s[0]-r[0])*(s[1]+r[1])}return t<0}static validateRing(e){const t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]}}var tn=k(67267),rt=k.n(tn);class V{static hexToRgb(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]:null}static fillTypedArraySequence(e,t){const n=e.length;let r=t.length,s=r;if(n>0)for(e.set(t);s<n;)s+r>n&&(r=n-s),e.copyWithin(s,0,r),s+=r,r<<=1;return e}static mergeTypedArrays(e,t){if(t.length>0){let n=0;for(let i=0;i<t.length;i++)n+=t[i].length;const r=new e(n);let s=0;for(let i=0;i<t.length;i++)r.set(t[i],s),s+=t[i].length;return r}return new e(0)}static isMobileBrowser(){let e=!1;return function(t){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(e=!0)}(navigator.userAgent||navigator.vendor),e}static resolveEndpointTemplate({values:e,template:t}){let n=t;for(const[r,s]of Object.entries(e))n=n.replace(`{${r}}`,s.toString());return n}}const nn=k(53434).n;class Ne{constructor(e){this.endpointTemplate=e}async getCollection({x:e,y:t,zoom:n}){const r=[],s=[],i=await this.fetchTile(e,t,n);for(const[a,l]of Object.entries(i))for(const c of l){const d=new de({type:a});for(const h of c)d.addRing(h);for(const h of d.getFeatures())r.push(h)}return{nodes:s,polylines:[],areas:r}}async fetchTile(e,t,n){const r=4007501668e-2/(1<<n),s={water:[],forest:[],shrubbery:[],farmland:[]},i=this.buildRequestURL(e,t,n),a=await fetch(i,{method:"GET"});if(a.status!==200&&(await a.json())?.message==="Tile not found")return s;const l=new(rt())(await a.arrayBuffer()),c=nn.read(l);for(const d of c.layers){const h=d.name,f=d.keys,p=d.values;if(h==="water")for(const g of d.features){const m=U.convertCommandsToPolygon(g.geometry,d.extent,r);s.water.push(m)}if(h==="landuse")for(const{geometry:g,tags:m}of d.features){const x={};for(let y=0;y<m.length;y+=2){const M=f[m[y]],S=p[m[y+1]];x[M]=S.string_value}if(x.type==="wood"||x.type==="forest"){const y=U.convertCommandsToPolygon(g,d.extent,r);s.forest.push(y)}if(x.type==="scrub"){const y=U.convertCommandsToPolygon(g,d.extent,r);s.shrubbery.push(y)}if(x.type==="farmland"){const y=U.convertCommandsToPolygon(g,d.extent,r);s.farmland.push(y)}}}return s}buildRequestURL(e,t,n){return V.resolveEndpointTemplate({template:this.endpointTemplate,values:{x:e,y:t,z:n}})}}class st{}class u{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){this.x=e,this.y=t}equals(e){return this.x===e.x&&this.y===e.y}static add(e,t){return new u(e.x+t.x,e.y+t.y)}static sub(e,t){return new u(e.x-t.x,e.y-t.y)}static addScalar(e,t){return new u(e.x+t,e.y+t)}static multiplyScalar(e,t){return new this(e.x*t,e.y*t)}static normalize(e){const t=new this,n=Math.sqrt(e.x**2+e.y**2);return n>1e-5&&(t.x=e.x/n,t.y=e.y/n),t}static getLength(e){return Math.sqrt(e.x**2+e.y**2)}static dot(e,t){const n=e.x*t.x+e.y*t.y;return n<=-1?-1:n>=1?1:n}static distance(e,t){return Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2)}static angleClockwise(e,t){const n=e.x*t.x+e.y*t.y,r=e.x*t.y-e.y*t.x;return Math.atan2(r,n)}getAngle(){return Math.atan2(this.y,this.x)}static rotate(e,t){return new u(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t))}static rotateLeft(e){return new u(-e.y,e.x)}static rotateRight(e){return new u(e.y,-e.x)}static applyMatrix3(e,t){const n=new u,r=t.values,s=e.x,i=e.y;return n.x=r[0]*s+r[3]*i+r[6],n.y=r[1]*s+r[4]*i+r[7],n}static lerp(e,t,n){return new u((1-n)*e.x+n*t.x,(1-n)*e.y+n*t.y)}static clone(e){return new this(e.x,e.y)}static toArray(e){return[e.x,e.y]}}const _=class{constructor(o=0,e=0,t=0){this.x=o,this.y=e,this.z=t}get xz(){return new u(this.x,this.z)}get xy(){return new u(this.x,this.y)}set(o,e,t){this.x=o,this.y=e,this.z=t}equals(o){return this.x===o.x&&this.y===o.y&&this.z===o.z}normalize(){const o=_.getLength(this);return o>1e-10&&(this.x/=o,this.y/=o,this.z/=o),this}static add(o,e){return new _(o.x+e.x,o.y+e.y,o.z+e.z)}static sub(o,e){return new _(o.x-e.x,o.y-e.y,o.z-e.z)}static addScalar(o,e){return new _(o.x+e,o.y+e,o.z+e)}static multiplyScalar(o,e){return new _(o.x*e,o.y*e,o.z*e)}static multiplyPerComponent(o,e){return new _(o.x*e.x,o.y*e.y,o.z*e.z)}static applyMatrix4(o,e){const t=new _,n=e.values,r=1/(n[3]*o.x+n[7]*o.y+n[11]*o.z+n[15]);return t.x=(n[0]*o.x+n[4]*o.y+n[8]*o.z+n[12])*r,t.y=(n[1]*o.x+n[5]*o.y+n[9]*o.z+n[13])*r,t.z=(n[2]*o.x+n[6]*o.y+n[10]*o.z+n[14])*r,t}static normalize(o){const e=_.getLength(o),t=new _;return e>1e-10&&(t.x=o.x/e,t.y=o.y/e,t.z=o.z/e),t}static getLength(o){return Math.sqrt(o.x**2+o.y**2+o.z**2)}static cross(o,e){const t=new _;return t.x=o.y*e.z-o.z*e.y,t.y=o.z*e.x-o.x*e.z,t.z=o.x*e.y-o.y*e.x,t}static dot(o,e){return o.x*e.x+o.y*e.y+o.z*e.z}static distance(o,e){return Math.hypot(o.x-e.x,o.y-e.y,o.z-e.z)}static lerp(o,e,t){return new _((1-t)*o.x+t*e.x,(1-t)*o.y+t*e.y,(1-t)*o.z+t*e.z)}static nlerp(o,e,t){return _.lerp(o,e,t).normalize()}static project(o,e){const t=_.applyMatrix4(o,e.matrixWorldInverse);return _.applyMatrix4(t,e.projectionMatrix)}static unproject(o,e,t=!0){const n=_.applyMatrix4(o,e.projectionMatrixInverse);return _.applyMatrix4(n,t?e.matrixWorld:e.matrix)}static rotateAroundAxis(o,e,t){const n=Math.cos(t),r=Math.sin(t),s=1-n,i=_.cross(e,o),a=_.dot(e,o);return new _(o.x*n+i.x*r+e.x*a*s,o.y*n+i.y*r+e.y*a*s,o.z*n+i.z*r+e.z*a*s)}static clone(o){return new _(o.x,o.y,o.z)}static toArray(o){return[o.x,o.y,o.z]}};let w=_;w.Empty=new _;class I{static clamp(e,t,n){return e<=t?t:e>=n?n:e}static lerp(e,t,n){return(1-n)*e+n*t}static shortestAngleDistance(e,t){const n=Math.PI*2,r=(t-e)%n;return 2*r%n-r}static lerpAngle(e,t,n){return e+this.shortestAngleDistance(e,t)*n}static toRad(e){return e*Math.PI/180}static toDeg(e){return e*180/Math.PI}static mod(e,t){return(e%t+t)%t}static normalizeAngle(e){return(e%=2*Math.PI)>=0?e:e+2*Math.PI}static polarToCartesian(e,t){return new w(Math.cos(t)*Math.cos(e),Math.sin(t),Math.cos(t)*Math.sin(e))}static cartesianToPolar(e){const t=Math.atan2(e.x,-e.z)+Math.PI/2,n=Math.sqrt(e.x*e.x+e.z*e.z);return[Math.atan2(e.y,n),t]}static degrees2meters(e,t){const n=t*2003750834e-2/180,r=Math.log(Math.tan((90+e)*Math.PI/360))*2003750834e-2/Math.PI;return new u(r,n)}static meters2degrees(e,t){const n=t*180/2003750834e-2;return{lat:Math.atan(Math.exp(e*Math.PI/2003750834e-2))*360/Math.PI-90,lon:n}}static degrees2tile(e,t,n=16){const r=(t+180)/360*(1<<n),s=(1-Math.log(Math.tan(e*Math.PI/180)+1/Math.cos(e*Math.PI/180))/Math.PI)/2*(1<<n);return new u(r,s)}static tile2degrees(e,t,n=16){const r=Math.PI-2*Math.PI*t/(1<<n),s=180/Math.PI*Math.atan(.5*(Math.exp(r)-Math.exp(-r))),i=e/(1<<n)*360-180;return{lat:s,lon:i}}static meters2tile(e,t,n=16){const r=(t+2003750834e-2)/4007501668e-2*(1<<n),s=(1-(e+2003750834e-2)/(2*2003750834e-2))*(1<<n);return new u(r,s)}static tile2meters(e,t,n=16){const r=4007501668e-2*e/(1<<n)-2003750834e-2,s=2003750834e-2-2*2003750834e-2*t/(1<<n);return new u(s,r)}static getTileSizeInMeters(e){return 4007501668e-2/(1<<e)}static getTilesIntersectingLine(e,t){let n=Math.floor(e.x),r=Math.floor(e.y);const s=Math.floor(t.x),i=Math.floor(t.y),a=[new u(n,r)];if(n===s&&r===i)return a;const l=Math.sign(t.x-e.x),c=Math.sign(t.y-e.y),d=Math.abs(e.x-n-Math.max(0,l)),h=Math.abs(e.y-r-Math.max(0,c)),f=Math.abs(e.x-t.x),p=Math.abs(e.y-t.y);let g=d===0?0:d/f,m=h===0?0:h/p;const x=1/f,y=1/p;let M=0;for(;!(n===s&&r===i)&&M<1e4;)g<=m?(g=g+x,n=n+l):(m=m+y,r=r+c),a.push(new u(n,r)),M++;return a}static getMercatorScaleFactor(e){return 1/Math.cos(I.toRad(e))}static getMercatorScaleFactorForTile(e,t,n){const{lat:r}=I.tile2degrees(e,t,n);return this.getMercatorScaleFactor(r)}static shiftLeft(e,t){return e*Math.pow(2,t)}static shiftRight(e,t){return Math.floor(e/Math.pow(2,t))}static calculateNormal(e,t,n){let r=w.sub(n,t);const s=w.sub(e,t);return r=w.cross(r,s),w.normalize(r)}static getBarycentricCoordinatesOfPoint(e,t){const n=new u(t[0],t[1]),r=new u(t[2],t[3]),s=new u(t[4],t[5]),i=u.sub(r,n),a=u.sub(s,n),l=u.sub(e,n),c=i.x*a.y-a.x*i.y,d=(l.x*a.y-a.x*l.y)/c,h=(i.x*l.y-l.x*i.y)/c,f=1-d-h;return new w(f,d,h)}static isTriangleDegenerate(e){const t=new u(e[0],e[1]),n=new u(e[2],e[3]),r=new u(e[4],e[5]),s=u.sub(n,t),i=u.sub(r,t);return s.x*i.y-i.x*s.y===0}static getTriangleAreaSigned(e,t,n){return(e[0]-n[0])*(t[1]-n[1])-(t[0]-n[0])*(e[1]-n[1])}static isPointInTriangle(e,t){const[n,r,s]=t,i=I.getTriangleAreaSigned(e,n,r),a=I.getTriangleAreaSigned(e,r,s),l=I.getTriangleAreaSigned(e,s,n),c=i<0||a<0||l<0,d=i>0||a>0||l>0;return!(c&&d)}static getIntersectionLineLine(e,t,n,r){const[s,i]=e,[a,l]=t,[c,d]=n,[h,f]=r;if(s===a&&i===l||c===h&&d===f)return null;const p=(f-d)*(a-s)-(h-c)*(l-i);if(p===0)return null;const g=((h-c)*(i-d)-(f-d)*(s-c))/p,m=((a-s)*(i-d)-(l-i)*(s-c))/p;if(g<0||g>1||m<0||m>1)return null;const x=s+g*(a-s),y=i+g*(l-i);return[x,y]}static getIntersectionLineLineInfinite(e,t,n,r){const{x:s,y:i}=e,{x:a,y:l}=t,{x:c,y:d}=n,{x:h,y:f}=r,p=a-s,g=l-i,m=h-c,x=f-d,y=p*x-g*m;if(y===0)return null;const M=((c-s)*x-(d-i)*m)/y;return new u(s+M*p,i+M*g)}static getIntersectionsLineTriangle(e,t,n){const r=[];for(let s=0;s<n.length;s++){const i=s+1==n.length?0:s+1,a=I.getIntersectionLineLine(e,t,n[s],n[i]);a&&r.push(a)}return r}static orderConvexPolygonPoints(e){let t=0,n=0;for(const s of e)t+=s[0],n+=s[1];t/=e.length,n/=e.length;const r=new Map;for(const s of e)r.set(s,Math.atan2(s[1]-n,s[0]-t));return e.sort((s,i)=>r.get(s)-r.get(i)),e}static findIntersectionTriangleTriangle(e,t){const n=[],r=s=>{n.some(i=>s[0]===i[0]&&s[1]===i[1])||n.push(s)};for(const s of e)I.isPointInTriangle(s,t)&&r(s);for(const s of t)I.isPointInTriangle(s,e)&&r(s);for(let s=0,i=1;s<e.length;s++,i=s+1==e.length?0:s+1){const a=I.getIntersectionsLineTriangle(e[s],e[i],t);for(const l of a)r(l)}return I.orderConvexPolygonPoints(n)}static getPolygonCentroid(e){const t=e[0].x,n=e[0].y;let r=0,s=0,i=0,a=e[e.length-1];for(const c of e){const d=a.x-t,h=a.y-n,f=c.x-t,p=c.y-n,g=d*p-f*h;i+=g,r+=(d+f)*g,s+=(h+p)*g,a=c}const l=3*i;return r/=l,s/=l,new u(r+t,s+n)}static isPointInsidePolygon(e,t){const{x:n,y:r}=e;let s=!1;for(let i=0,a=t.length-1;i<t.length;a=i++){const l=t[i].x,c=t[i].y,d=t[a].x,h=t[a].y;c>r!=h>r&&n<(d-l)*(r-c)/(h-c)+l&&(s=!s)}return s}static getPointProgressAlongLineSegment(e,t,n,r=!0){const s=t.x-e.x,i=t.y-e.y,a=s*s+i*i,c=((n.x-e.x)*s+(n.y-e.y)*i)/a;return r?I.clamp(c,0,1):c}static getTilesUnderTriangle(e,t,n,r=-1/0,s=-1/0,i=1/0,a=1/0){const l=t,c=n,d=new u(e[0][0]*l,e[0][1]*c),h=new u(e[1][0]*l,e[1][1]*c),f=new u(e[2][0]*l,e[2][1]*c),p=I.getTilesIntersectingLine(d,h),g=I.getTilesIntersectingLine(h,f),m=I.getTilesIntersectingLine(f,d),x=p.concat(g,m),y=[];let M=1/0,S=-1/0,F=0;for(const R of x)M<=R.y&&(F=Math.min(R.x,F)),M=Math.min(R.y,M),S=Math.max(R.y,S);for(let R=M;R<=S;R++){let D=1/0,N=-1/0;for(const O of x)O.y===R&&(D=Math.min(D,O.x),N=Math.max(N,O.x));for(let O=D;O<=N;O++)O<r||O>i||R<s||R>a||y.push(new u(O,R))}return y}static getPolygonAreaSigned(e){let t=0,n=e[e.length-1];for(const r of e)t+=n.x*r.y-r.x*n.y,n=r;return t/2}}function rn(o){return o??{}}function He(o){o=rn(o);for(const[e,t]of Object.entries(o))o[e]=t.trim();return o}function ot(o){const e={nodes:[],polylines:[],areas:[]};for(const t of o)switch(t.type){case"node":e.nodes.push(t);break;case"polyline":e.polylines.push(t);break;case"area":e.areas.push(t);break}return e}function We(o){const e={type:q.None,id:0};switch(o.osmType){case 0:e.type=q.Node;break;case 1:e.type=q.Way;break;case 2:e.type=q.Relation;break}return o.osmId!==void 0&&(e.id=o.osmId),e}class ge{}var b=(o=>(o[o.Descriptor=0]="Descriptor",o[o.Modifier=1]="Modifier",o))(b||{});const sn=JSON.parse('{"aliceblue":[240,248,255],"antiquewhite":[250,235,215],"aqua":[0,255,255],"aquamarine":[127,255,212],"azure":[240,255,255],"beige":[245,245,220],"bisque":[255,228,196],"black":[0,0,0],"blanchedalmond":[255,235,205],"blue":[0,0,255],"blueviolet":[138,43,226],"brown":[165,42,42],"burlywood":[222,184,135],"cadetblue":[95,158,160],"chartreuse":[127,255,0],"chocolate":[210,105,30],"coral":[255,127,80],"cornflowerblue":[100,149,237],"cornsilk":[255,248,220],"crimson":[220,20,60],"cyan":[0,255,255],"darkblue":[0,0,139],"darkcyan":[0,139,139],"darkgoldenrod":[184,134,11],"darkgray":[169,169,169],"darkgreen":[0,100,0],"darkgrey":[169,169,169],"darkkhaki":[189,183,107],"darkmagenta":[139,0,139],"darkolivegreen":[85,107,47],"darkorange":[255,140,0],"darkorchid":[153,50,204],"darkred":[139,0,0],"darksalmon":[233,150,122],"darkseagreen":[143,188,143],"darkslateblue":[72,61,139],"darkslategray":[47,79,79],"darkslategrey":[47,79,79],"darkturquoise":[0,206,209],"darkviolet":[148,0,211],"deeppink":[255,20,147],"deepskyblue":[0,191,255],"dimgray":[105,105,105],"dimgrey":[105,105,105],"dodgerblue":[30,144,255],"firebrick":[178,34,34],"floralwhite":[255,250,240],"forestgreen":[34,139,34],"fuchsia":[255,0,255],"gainsboro":[220,220,220],"ghostwhite":[248,248,255],"gold":[255,215,0],"goldenrod":[218,165,32],"gray":[128,128,128],"green":[0,128,0],"greenyellow":[173,255,47],"grey":[128,128,128],"honeydew":[240,255,240],"hotpink":[255,105,180],"indianred":[205,92,92],"indigo":[75,0,130],"ivory":[255,255,240],"khaki":[240,230,140],"lavender":[230,230,250],"lavenderblush":[255,240,245],"lawngreen":[124,252,0],"lemonchiffon":[255,250,205],"lightblue":[173,216,230],"lightcoral":[240,128,128],"lightcyan":[224,255,255],"lightgoldenrodyellow":[250,250,210],"lightgray":[211,211,211],"lightgreen":[144,238,144],"lightgrey":[211,211,211],"lightpink":[255,182,193],"lightsalmon":[255,160,122],"lightseagreen":[32,178,170],"lightskyblue":[135,206,250],"lightslategray":[119,136,153],"lightslategrey":[119,136,153],"lightsteelblue":[176,196,222],"lightyellow":[255,255,224],"lime":[0,255,0],"limegreen":[50,205,50],"linen":[250,240,230],"magenta":[255,0,255],"maroon":[128,0,0],"mediumaquamarine":[102,205,170],"mediumblue":[0,0,205],"mediumorchid":[186,85,211],"mediumpurple":[147,112,219],"mediumseagreen":[60,179,113],"mediumslateblue":[123,104,238],"mediumspringgreen":[0,250,154],"mediumturquoise":[72,209,204],"mediumvioletred":[199,21,133],"midnightblue":[25,25,112],"mintcream":[245,255,250],"mistyrose":[255,228,225],"moccasin":[255,228,181],"navajowhite":[255,222,173],"navy":[0,0,128],"oldlace":[253,245,230],"olive":[128,128,0],"olivedrab":[107,142,35],"orange":[255,165,0],"orangered":[255,69,0],"orchid":[218,112,214],"palegoldenrod":[238,232,170],"palegreen":[152,251,152],"paleturquoise":[175,238,238],"palevioletred":[219,112,147],"papayawhip":[255,239,213],"peachpuff":[255,218,185],"peru":[205,133,63],"pink":[255,192,203],"plum":[221,160,221],"powderblue":[176,224,230],"purple":[128,0,128],"rebeccapurple":[102,51,153],"red":[255,0,0],"rosybrown":[188,143,143],"royalblue":[65,105,225],"saddlebrown":[139,69,19],"salmon":[250,128,114],"sandybrown":[244,164,96],"seagreen":[46,139,87],"seashell":[255,245,238],"sienna":[160,82,45],"silver":[192,192,192],"skyblue":[135,206,235],"slateblue":[106,90,205],"slategray":[112,128,144],"slategrey":[112,128,144],"snow":[255,250,250],"springgreen":[0,255,127],"steelblue":[70,130,180],"tan":[210,180,140],"teal":[0,128,128],"thistle":[216,191,216],"tomato":[255,99,71],"turquoise":[64,224,208],"violet":[238,130,238],"wheat":[245,222,179],"white":[255,255,255],"whitesmoke":[245,245,245],"yellow":[255,255,0],"yellowgreen":[154,205,50]}');function oe(o,e,t){const n=o[e];return n===void 0?!1:n.split(";").map(s=>s.trim().toLowerCase()).some(s=>s===t)}function Ve(o,e){const t=o[e];return t===void 0?[]:t.split(";").map(n=>n.trim().toLowerCase())}function it(o,e){const t=o[e],n=parseFloat(t);if(!isNaN(n))return n}function on(o,e){const t=it(o,e);if(t!==void 0)return Math.max(t,0)}function an(o,e){const t=o[e],n=parseInt(t);if(!isNaN(n))return n}function ye(o,e){const t=an(o,e);if(t!==void 0)return Math.max(t,0)}function K(o="",e=1){if(o=o.replace(/,/g,".").replace(/ /g,"").replace(/ft/g,"'").replace(/feet/g,"'"),o.search(/cm/)!==-1)return parseFloat(o.replace(/cm/g,""))*.01;if(o.search(/m/)!==-1)return parseFloat(o.replace(/m/g,""));if(o.search(/'/)!==-1){const[n,r]=o.split("'").map(s=>parseFloat(s));return(n*12+(r||0))*.0254}else if(o.search(/"/)!==-1)return(parseFloat(o)||0)*.0254;const t=parseFloat(o);return isNaN(t)?void 0:t*e}function ee(o="",e){return K(o)??e}function ln(o,e){const t=ye(o,e);if(!(t===void 0||t<=0))return t}function at(o="",e){const n={N:0,NE:45,E:90,SE:135,S:180,SW:225,W:270,NW:315,NNW:337.5,NNE:22.5,ENE:67.5,ESE:112.5,SSE:157.5,SSW:202.5,WSW:247.5,WNW:292.5}[o.toUpperCase()];if(n!==void 0)return n;const r=parseFloat(o);return isNaN(r)?e:r}function lt(o="",e){if(o.length===0)return e;const t=o.replace(/[ _-]/g,"").toLowerCase();let n=sn[t];if(!n){const r=o.includes(";")?o.split(";")[0]:o;n=V.hexToRgb(r)}return n?n[0]*256*256+n[1]*256+n[2]:e}function Ee(o){const e=o.tunnel!==void 0&&o.tunnel!=="no";return o.location==="underground"||it(o,"level")<0||e||o.parking==="underground"}var ne=(o=>(o[o.NodeRow=0]="NodeRow",o[o.CircleArea=1]="CircleArea",o))(ne||{});const ct={beech:"beech",fir:"fir",linden:"linden",oak:"oak"};function ut(o){const e=ct[o.genus];if(e)return e;const t=ct[o["genus:en"]];return t||(o.leaf_type==="needleleaved"?"genericNeedleleaved":"genericBroadleaved")}function cn(o){const e=K(o.min_height)||0;let t=(K(o.height)||K(o.est_height))-e;if(!t){let n=K(o.diameter_crown);n||(n=(K(o.diameter,.001)||K(o.circumference)/Math.PI)*23),n>.5&&n<100&&(t=n*2)}return t||void 0}class un extends ge{fromTags(e){return Ee(e)?null:e.natural==="tree"?[{type:b.Descriptor,data:{type:"tree",height:cn(e),treeType:ut(e)}}]:e.emergency==="fire_hydrant"&&(e["fire_hydrant:type"]==="pillar"||e["fire_hydrant:type"]===void 0)?[{type:b.Descriptor,data:{type:"hydrant"}}]:e.advertising==="column"?[{type:b.Descriptor,data:{type:"adColumn"}}]:e.power==="tower"?[{type:b.Descriptor,data:{type:"transmissionTower"}}]:e.power==="pole"?[{type:b.Descriptor,data:{type:"utilityPole"}}]:e.natural==="rock"?[{type:b.Descriptor,data:{type:"rock"}}]:e.amenity==="bench"?[{type:b.Descriptor,data:{type:"bench",direction:at(e.direction,void 0)}}]:e.leisure==="picnic_table"?[{type:b.Descriptor,data:{type:"picnicTable"}}]:e.highway==="bus_stop"?[{type:b.Descriptor,data:{type:"busStop"}}]:e.power==="generator"&&e["generator:source"]==="wind"?[{type:b.Descriptor,data:{type:"windTurbine",height:ee(e.height,150)}}]:e.historic==="memorial"&&oe(e,"memorial","statue")||e.tourism==="artwork"&&oe(e,"artwork_type","statue")?[{type:b.Descriptor,data:{type:"statue"}}]:e.tourism==="artwork"&&oe(e,"artwork_type","sculpture")||e.historic==="memorial"&&oe(e,"memorial","sculpture")?[{type:b.Descriptor,data:{type:"sculpture"}}]:e.historic==="memorial"&&(oe(e,"memorial","war_memorial")||oe(e,"memorial","stele")||oe(e,"memorial","obelisk")||oe(e,"memorial","memorial"))?[{type:b.Descriptor,data:{type:"memorial"}}]:e.highway==="turning_circle"?[{type:b.Modifier,data:{type:ne.CircleArea,radius:10,descriptor:{type:"roadwayIntersection",intersectionMaterial:"asphalt"}}}]:e.aeroway==="helipad"?[{type:b.Modifier,data:{type:ne.CircleArea,radius:8,descriptor:{type:"helipad"}}}]:null}}class qe{constructor(e,t,n){this.disableFeatureOutput=!1,this.cachedFeatures=null,this.cachedStructuralFeature=null,this.x=t,this.y=n,this.osmElement=e,this.tags=He(e.tags)}getFeaturesFromTags(){const e=[],t=new un().fromTags(this.tags);if(!t)return e;for(const n of t)switch(n.type){case b.Descriptor:{e.push({type:"node",x:this.x,y:this.y,rotation:0,osmReference:this.getOSMReference(),descriptor:n.data});break}case b.Modifier:{if(n.data.type===ne.CircleArea){const r=qe.getCircleAreaRing(this.x,this.y,n.data.radius);e.push({type:"area",osmReference:this.getOSMReference(),descriptor:n.data.descriptor,rings:[r]})}else console.error(`Unexpected modifier ${n.data.type}`);break}}return e}getFeatures(){return this.cachedFeatures||(this.cachedFeatures=this.getFeaturesFromTags()),this.cachedFeatures}getStructuralFeature(){return this.cachedStructuralFeature||(this.cachedStructuralFeature={type:"node",x:this.x,y:this.y,rotation:0,osmReference:null,descriptor:null}),this.cachedStructuralFeature}getOSMReference(){return{type:q.Node,id:this.osmElement.id}}preventFeatureOutput(){this.disableFeatureOutput=!0}markAsBuildingPartInRelation(){}static getCircleAreaRing(e,t,n){const r=[];for(let i=0;i<16;i++){const a=i/16,l=Math.PI*2*a,c=u.rotate(new u(n,0),l);r.push({type:"node",x:e+c.x,y:t+c.y,osmReference:null,descriptor:null,rotation:0})}return r.push(r[0]),{type:W.Outer,nodes:r}}}const dt=o=>o.slice(1),ht=o=>o.slice(0,o.length-1);class Pe{constructor(e,t){this.nodes=e,this.type=t}get firstNode(){return this.nodes[0]}get lastNode(){return this.nodes[this.nodes.length-1]}tryMerge(e){return this.type!==e.type?!1:this.firstNode===e.firstNode?(this.nodes=[...ht(this.nodes.reverse()),...e.nodes],!0):this.lastNode===e.firstNode?(this.nodes=[...ht(this.nodes),...e.nodes],!0):this.firstNode===e.lastNode?(this.nodes=[...e.nodes,...dt(this.nodes)],!0):this.lastNode===e.lastNode?(this.nodes=[...e.nodes,...dt(this.nodes.reverse())],!0):!1}getGaussArea(){const e=this.nodes;let t=0;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1]??e[0];t+=(s.x-r.x)*(s.y+r.y)}return t}fixDirection(){const e=this.getGaussArea();(e>0&&this.type===W.Inner||e<0&&this.type===W.Outer)&&this.nodes.reverse()}getVectorAreaRing(){return{type:this.type,nodes:this.nodes}}calculateLength(){let e=0;for(let t=0;t<this.nodes.length-1;t++){let n=this.nodes[t],r=this.nodes[t+1];e+=Math.sqrt((r.x-n.x)**2+(r.y-n.y)**2)}return e}distributeNodes(e,t,n){const r=this.calculateLength(),s=Math.floor(r/e),i=[];if(s>1){let a=r/(s-1),l=0,c=0,d=null,h=0,f=0,p=0;i.push([this.nodes[0].x,this.nodes[0].y]);for(let g=0;g<s-1;g++){for(;c<a&&l<this.nodes.length-1;)d=[this.nodes[l],this.nodes[l+1]],h=Math.hypot(d[1].x-d[0].x,d[1].y-d[0].y),c+=h,p+=h,l++;c-=a,f+=a;const m=(p-f)/h,x={x:d[1].x-d[0].x,y:d[1].y-d[0].y},y={x:d[1].x-x.x*m,y:d[1].y-x.y*m};t>0&&(y.x+=(Math.random()-.5)*t,y.y+=(Math.random()-.5)*t),i.push([y.x,y.y])}}return i.map(([a,l])=>({type:"node",x:a,y:l,rotation:0,descriptor:n,osmReference:{type:q.None,id:0}}))}}const dn={asphalt:"asphalt",unpaved:"dirt",paved:"asphalt",ground:"dirt",concrete:"concrete",paving_stones:"cobblestone",gravel:"dirt",dirt:"dirt",grass:"dirt",compacted:"dirt",sand:"sand",sett:"cobblestone",fine_gravel:"dirt",wood:"wood",cobblestone:"cobblestone",earth:"dirt",pebblestone:"cobblestone"},hn={residential:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},service:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!1},track:{type:"roadway",defaultMaterial:"dirt",defaultLanes:1,defaultIsMarked:!1},unclassified:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},tertiary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},secondary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},primary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},living_street:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!1},trunk:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},motorway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},motorway_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},trunk_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},primary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},secondary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},tertiary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},busway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},raceway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultWidth:6,defaultIsMarked:!1},footway:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},path:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},steps:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},pedestrian:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},cycleway:{type:"cycleway",defaultMaterial:"dirt",defaultLanes:1}};function fn(o){const e=hn[o.highway];if(!e)return null;const t=dn[o.surface]??e.defaultMaterial;return{type:e.type,material:t,defaultLanes:e.defaultLanes,defaultWidth:e.defaultWidth,defaultIsMarked:e.defaultIsMarked??!0}}function pn(o){const e=o["sidewalk:both"]==="yes"||o.sidewalk==="both",t=o["sidewalk:left"]==="yes"||o.sidewalk==="left"||e,n=o["sidewalk:right"]==="yes"||o.sidewalk==="right"||e;return t&&n?"both":t?"left":n?"right":null}function gn(o){const e=o["cycleway:both"]==="lane",t=o["cycleway:left"]==="lane"||e,n=o["cycleway:right"]==="lane"||e;return t&&n?"both":t?"left":n?"right":null}const ft={wood:["wood",2],chain_link:["chainLink",3],wire:["chainLink",3],metal:["metal",1.5],railing:["metal",1.5],concrete:["concrete",2.5]};function yn(o){const e=ft[o]??ft.metal;return{material:e[0],defaultHeight:e[1]}}const pt={dry_stone:["stone",3],stone:["stone",3],brick:["stone",3],concrete:["concrete",3],concrete_block:["concrete",3]};function mn(o){const e=o.wall,t=pt[e]??pt.concrete,n=t[0],r=ee(o.height,t[1]);return{material:n,height:r}}const gt={rail:{type:"railway",gauge:1435},light_rail:{type:"railway",gauge:1435},subway:{type:"railway",gauge:1435},disused:{type:"railway",gauge:1435},narrow_gauge:{type:"railway",gauge:1e3},tram:{type:"tramway",gauge:1435}},yt={broad:1676,standard:1435,narrow:1e3};function xn(o,e){const t=Ve(o,"gauge");let n=e;if(t.length>0){const r=t.map(s=>yt[s]!==void 0?yt[s]:parseInt(s)).filter(s=>!isNaN(s));r.length>0&&(n=Math.max(...r))}return n}function wn(o){const e=gt[o.railway]??gt[o.rail],t=xn(o,e.gauge);return{type:e.type,width:t/1e3}}function bn(o,e,t){return e===1||o.placement==="transition"||o.lane_markings==="no"?!1:o.lane_markings==="yes"?!0:t}const Mn={river:10,stream:2,canal:8,drain:1,ditch:1};function vn(o){const e=Mn[o.waterway];return e===void 0?null:{width:ee(o.width,e)}}class Sn extends ge{fromTags(e){if(Ee(e)||e.area==="yes")return null;if(e.highway){const t=fn(e);if(!t)return[];const n={type:"path",pathMaterial:t.material};switch(t.type){case"roadway":{n.pathType="roadway";const s=e.oneway==="yes"||e.junction==="roundabout";let i=ye(e,"lanes:forward"),a=ye(e,"lanes:backward");const l=ye(e,"lanes")??(s?Math.max(1,Math.floor(t.defaultLanes/2)):t.defaultLanes);s?(i=l,a=0):i===void 0&&a===void 0?(i=Math.ceil(l/2),a=l-i):i===void 0?i=Math.max(0,l-a):a===void 0&&(a=Math.max(0,l-i)),n.lanesForward=i,n.lanesBackward=a;const c=K(e.width),d=i+a;if(c===void 0&&t.defaultWidth!==void 0)n.width=t.defaultWidth;else{const h=d===1?4:3;n.width=d*h}n.isRoadwayMarked=bn(e,d,t.defaultIsMarked);break}case"footway":{n.pathType="footway",n.width=K(e.width)??2;break}case"cycleway":{n.pathType="cycleway",n.width=K(e.width)??3;break}}const r=[{type:b.Descriptor,data:n}];if(n.pathType==="roadway"){const a=pn(e),l=gn(e),c=n.width;if(l&&r.push({type:b.Descriptor,data:{type:"path",pathType:"cycleway",width:c+4,side:l}}),a)if(!l||l==="both")r.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:c+4+(l==="both"?4:0),side:a}});else{if(a==="left"||a==="both"){const d=l==="left"?1:0,h=c+2*2+d*2*2;r.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:h,side:"left"}})}if(a==="right"||a==="both"){const d=l==="right"?1:0,h=c+2*2+d*2*2;r.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:h,side:"right"}})}}}return r}if(e.aeroway==="runway"||e.aeroway==="taxiway"){const t=K(e.width)??(e.aeroway==="runway"?45:20);return[{type:b.Descriptor,data:{type:"path",pathType:"runway",width:t}}]}if(e.railway==="rail"||e.railway==="light_rail"||e.railway==="subway"||e.railway==="disused"||e.railway==="narrow_gauge"||e.railway==="tram"){const{type:t,width:n}=wn(e);return[{type:b.Descriptor,data:{type:"path",pathType:t,width:n}}]}if(e.barrier==="fence"){const t=yn(e.fence_type),n=ee(e.min_height,0),r=ee(e.height,t.defaultHeight)-n;return r<=0?[]:[{type:b.Descriptor,data:{type:"fence",fenceMaterial:t.material,height:r,minHeight:n}}]}if(e.barrier==="hedge")return[{type:b.Descriptor,data:{type:"wall",wallType:"hedge",height:ee(e.height,1)}}];if(e.barrier==="wall"){const{material:t,height:n}=mn(e);return[{type:b.Descriptor,data:{type:"wall",wallType:t,height:n}}]}if(e.power==="line"||e.power==="minor_line")return[{type:b.Descriptor,data:{type:"powerLine"}}];if(e.natural==="tree_row")return[{type:b.Modifier,data:{type:ne.NodeRow,spacing:10,randomness:1,descriptor:{type:"tree",height:ee(e.height,void 0),treeType:ut(e)}}}];if(e.waterway){const t=vn(e);if(t)return[{type:b.Descriptor,data:{type:"waterway",width:t.width}}]}return null}}function kn(o){return o==="along"||o==="across"?o:null}const Tn={flat:0,hipped:1,gabled:1,gambrel:1,pyramidal:1,onion:2,dome:2,round:2,skillion:1,mansard:1,quadrupleSaltbox:1,saltbox:1};function In(o){return Tn[o]}const mt={brick:{type:"brick",defaultColor:9193524},cement_block:{type:"cementBlock",defaultColor:16777215},block:{type:"cementBlock",defaultColor:16777215},wood:{type:"wood",defaultColor:16777215},plaster:{type:"plaster",defaultColor:16777215},plastered:{type:"plaster",defaultColor:16777215},concrete:{type:"plaster",defaultColor:14540253},hard:{type:"plaster",defaultColor:14540253},glass:{type:"glass",defaultColor:16777215},mirror:{type:"glass",defaultColor:16777215}};function Fn(o){const e=o["building:material"],t=o["building:colour"],n=mt[e]??mt.plaster,r=lt(t,n.defaultColor);return{material:n.type,color:r}}const Rn=["garage","garages","greenhouse","storage_tank","bunker","silo","stadium","ship","castle","service","digester","water_tower","shed","ger","barn","slurry_tank","container","carport"];function Pn(o){return o.window==="no"||o.windows==="no"?!1:o.window==="yes"||o.windows==="yes"?!0:o["bridge:support"]||o.man_made==="storage_tank"||o.man_made==="chimney"||o.man_made==="stele"?!1:!Rn.includes(o.building)}const Bn={flat:"flat",hipped:"hipped",gabled:"gabled",gambrel:"gambrel",pyramidal:"pyramidal",onion:"onion",dome:"dome",round:"round",skillion:"skillion",mansard:"mansard",quadruple_saltbox:"quadrupleSaltbox",saltbox:"saltbox"};function An(o,e="flat"){return Bn[o]??e}const Ln={tile:"tiles",tiles:"tiles",roof_tiles:"tiles",slate:"tiles",metal:"metal",metal_sheet:"metal","metal sheet":"metal",tin:"metal",copper:"metal",zinc:"metal",concrete:"concrete",asphalt:"concrete",eternit:"eternit",asbestos:"eternit",thatch:"thatch",grass:"grass",glass:"glass",tar_paper:"tar"};function Dn(o,e="concrete"){return Ln[o]??e}const On=["roof","stadium","houseboat","castle","greenhouse","storage_tank","silo","stadium","ship","bridge","digester","water_tower","shed"];function Cn(o){return o["bridge:support"]||o["ship:type"]||o.man_made==="storage_tank"||o.man_made==="chimney"||o.man_made==="stele"?!1:!On.includes(o.building)}function zn(o){const e=An(o["roof:shape"],"flat"),t=!Cn(o)||e!=="flat",n=o["roof:material"],r=o["roof:colour"];let s=Dn(n,"default"),i=lt(r,null);if((i!==null||t)&&s==="default"&&(s="concrete"),i===null)switch(s){case"concrete":{i=12303291;break}case"metal":{i=n==="copper"?10734269:12833501;break}case"tiles":{i=n==="slate"?9211031:13335908;break}default:i=16777215}return{type:e,material:s,color:i}}function xt(o,e=!1){const r=!e&&o["building:levels"]===void 0&&o["building:min_level"]===void 0&&o.height===void 0&&o.est_height===void 0&&o.min_height===void 0,s=zn(o),i=kn(o["roof:orientation"]),a=ln(o,"roof:levels")??In(s.type),l=at(o["roof:direction"],null),c=on(o,"roof:angle");let d=ee(o["roof:height"],a*4),h=ye(o,"building:min_level")??null,f=ee(o.height,ee(o.est_height,null)),p=ye(o,"building:levels")??null,g=ee(o.min_height,null);f!==null&&(d=Math.min(d,f-(g??0))),f===null&&p===null?(p=h!==null?h:1,f=p*4+d):f===null?f=p*4+d:p===null&&(p=Math.max(1,Math.round((f-d)/4))),h===null&&(g!==null?h=Math.min(p-1,Math.round(g/4)):h=0),g===null&&(g=Math.min(h*4,f));const m=Fn(o),x=o.name??null;let y=Pn(o);return f-g-d<2&&(y=!1),{label:x,buildingLevels:p-h,buildingHeight:f,buildingMinHeight:e?f-d:g,buildingRoofHeight:d,buildingRoofType:s.type,buildingRoofOrientation:i,buildingRoofDirection:l,buildingRoofAngle:c,buildingFacadeMaterial:m.material,buildingFacadeColor:m.color,buildingRoofMaterial:s.material,buildingRoofColor:s.color,buildingWindows:y,buildingFoundation:r}}const Gn={soccer:"football",tennis:"tennis",basketball:"basketball"};function Nn(o){const e=Ve(o,"sport");for(const t of e){const n=Gn[t];if(n==="basketball"&&Ve(o,"hoops")[0]=="1")return"generic";if(n!==void 0)return n}return"generic"}class wt extends ge{fromTags(e){if(Ee(e))return null;if(e["building:part"]&&e["building:part"]!=="no")return[{type:b.Descriptor,data:{type:"buildingPart",...xt(e,e["building:part"]==="roof")}}];if(e.building&&e.building!=="no"&&e.building!=="construction")return[{type:b.Descriptor,data:{type:"building",...xt(e,e.building==="roof")}}];if(e.natural==="sand"||e.natural==="beach")return[{type:b.Descriptor,data:{type:"sand"}}];if(e.natural==="rock"||e.natural==="bare_rock")return[{type:b.Descriptor,data:{type:"rock"}}];if(e.leisure==="pitch"){const n=Nn(e);return[{type:b.Descriptor,data:{type:"pitch",pitchType:n}}]}return e.leisure==="playground"||e.leisure==="dog_park"?[{type:b.Descriptor,data:{type:"pitch",pitchType:"generic"}}]:e.golf==="fairway"?[{type:b.Descriptor,data:{type:"manicuredGrass"}}]:e.leisure==="garden"?[{type:b.Descriptor,data:{type:"garden"}}]:e.landuse==="grass"?[{type:b.Descriptor,data:{type:"grass"}}]:e.leisure==="swimming_pool"&&e.location!=="indoor"&&e.location!=="roof"?[{type:b.Descriptor,data:{type:"water"}}]:e.landuse==="construction"||e.landuse==="brownfield"?[{type:b.Descriptor,data:{type:"construction"}}]:e.building==="construction"?[{type:b.Descriptor,data:{type:"buildingConstruction"}}]:e.amenity==="parking"&&(e.parking==="surface"||e.parking===void 0)||e.amenity==="bicycle_parking"?[{type:b.Descriptor,data:{type:"asphalt"}}]:["yes","primary","secondary","tertiary","motorway","trunk","unclassified","residential","service","emergency"].indexOf(e["area:highway"])>-1?[{type:b.Descriptor,data:{type:"roadwayArea"}}]:(e.area==="yes"||e.type==="multipolygon")&&(e.highway==="pedestrian"||e.highway==="footway"||e.man_made==="pier")?[{type:b.Descriptor,data:{type:"pavement"}}]:e["area:highway"]==="footway"||e["area:highway"]==="pedestrian"?[{type:b.Descriptor,data:{type:"pavement"}}]:e.man_made==="bridge"?[{type:b.Descriptor,data:{type:"pavement"}}]:e.aeroway==="apron"?[{type:b.Descriptor,data:{type:"pavement"}}]:e.aeroway==="helipad"?[{type:b.Descriptor,data:{type:"helipad"}}]:null}}class Hn{constructor(e,t){this.disableFeatureOutput=!1,this.isBuildingPartInRelation=!1,this.cachedFeatures=null,this.cachedStructuralFeature=null,this.osmElement=e,this.tags=He(e.tags),this.nodes=t}isClosed(){return this.nodes[0]===this.nodes[this.nodes.length-1]}preventFeatureOutput(){this.disableFeatureOutput=!0}markAsBuildingPartInRelation(){this.isBuildingPartInRelation=!0}getFeaturesFromPolylineTags(){const e=[],t=new Sn().fromTags(this.tags);if(!t)return e;for(const n of t)switch(n.type){case b.Descriptor:{e.push({type:"polyline",osmReference:this.getOSMReference(),descriptor:n.data,nodes:this.nodes.map(r=>r.getStructuralFeature())});break}case b.Modifier:{const r=n.data;if(r.type===ne.NodeRow){const i=new Pe(this.nodes.map(a=>a.getStructuralFeature()),W.Outer).distributeNodes(r.spacing,r.randomness,r.descriptor);e.push(...i)}else console.error(`Unexpected modifier ${r.type}`);break}}return e}getFeaturesFromAreaTags(){const e=[];if(!this.isClosed())return e;const t=new wt().fromTags(this.tags);if(!t)return e;for(const n of t)switch(n.type){case b.Descriptor:{const r=new Pe(this.nodes.map(s=>s.getStructuralFeature()),W.Outer);r.fixDirection(),e.push({type:"area",osmReference:this.getOSMReference(),descriptor:n.data,rings:[r.getVectorAreaRing()],isBuildingPartInRelation:this.isBuildingPartInRelation});break}case b.Modifier:{console.error(`Unexpected modifier ${n.data.type}`);break}}return e}getFeatures(){return this.disableFeatureOutput?[]:(this.cachedFeatures||(this.cachedFeatures=[...this.getFeaturesFromPolylineTags(),...this.getFeaturesFromAreaTags()]),this.cachedFeatures)}getStructuralFeature(){return this.cachedStructuralFeature||(this.cachedStructuralFeature={type:"polyline",osmReference:null,descriptor:null,nodes:this.nodes.map(e=>e.getStructuralFeature())}),this.cachedStructuralFeature}getOSMReference(){return{type:q.Way,id:this.osmElement.id}}}class Be{constructor(e){this.members=[],this.disableFeatureOutput=!1,this.isBuildingPartInRelation=!1,this.cachedFeatures=null,this.osmElement=e,this.tags=He(e.tags)}addMember(e,t){this.members.push({osmMember:e,handler:t}),this.tags.type==="building"&&(e.role==="outline"?t.preventFeatureOutput():e.role==="part"&&t.markAsBuildingPartInRelation())}getClosedMultipolygonRings(){const e=[];for(const{handler:n,osmMember:r}of this.members){const s=n.getStructuralFeature();if(s&&s.type==="polyline"){const i=Be.getRingTypeFromRole(r.role);e.push(new Pe(s.nodes,i))}}const t=Be.resolvePartialRings(e);for(const n of t)n.fixDirection();return t}preventFeatureOutput(){this.disableFeatureOutput=!0}markAsBuildingPartInRelation(){this.isBuildingPartInRelation=!0}getFeaturesFromAreaTags(){const e=[],t=new wt().fromTags(this.tags);if(!t)return[];for(const n of t){const r=this.getVectorAreaRings();if(!r.some(s=>s.type===W.Outer))return console.warn(`Relation ${this.osmElement.id} has no outer rings`),[];switch(n.type){case b.Descriptor:{e.push({type:"area",osmReference:this.getOSMReference(),descriptor:n.data,rings:r,isBuildingPartInRelation:this.isBuildingPartInRelation});break}case b.Modifier:{console.error(`Unexpected modifier ${n.data.type}`);break}}}return e}getVectorAreaRings(){return this.getClosedMultipolygonRings().map(e=>e.getVectorAreaRing())}getFeatures(){return this.disableFeatureOutput?[]:(this.cachedFeatures||(this.cachedFeatures=[],this.tags.type==="multipolygon"&&this.cachedFeatures.push(...this.getFeaturesFromAreaTags())),this.cachedFeatures)}getStructuralFeature(){return null}getOSMReference(){return{type:q.Relation,id:this.osmElement.id}}static resolvePartialRings(e){const t=[],n=[];for(const i of e)i.firstNode===i.lastNode?n.push(i):t.push(i);const r=new Set(t);for(const i of r)for(const a of r)a!==i&&i.tryMerge(a)&&r.delete(a);const s=Array.from(r).filter(i=>i.firstNode===i.lastNode);return[...n,...s]}static getRingTypeFromRole(e){return e==="inner"?W.Inner:W.Outer}}class bt{constructor(){this.isEmpty=!0}}class me extends bt{constructor(e,t){super(),e&&t?(this.isEmpty=!1,this.min=e,this.max=t):(this.min=new u,this.max=new u)}includePoint(e){this.isEmpty&&(this.min.set(e.x,e.y),this.max.set(e.x,e.y),this.isEmpty=!1),this.min.x=Math.min(this.min.x,e.x),this.min.y=Math.min(this.min.y,e.y),this.max.x=Math.max(this.max.x,e.x),this.max.y=Math.max(this.max.y,e.y)}includeAABB(e){this.isEmpty&&(this.min.set(e.min.x,e.min.y),this.max.set(e.max.x,e.max.y),this.isEmpty=!1),this.min.x=Math.min(this.min.x,e.min.x),this.min.y=Math.min(this.min.y,e.min.y),this.max.x=Math.max(this.max.x,e.max.x),this.max.y=Math.max(this.max.y,e.max.y)}includesPoint(e){return this.min.x<=e.x&&e.x<=this.max.x&&this.min.y<=e.y&&e.y<=this.max.y}intersectsAABB(e){return this.isEmpty||e.isEmpty?!1:!(e.max.x<=this.min.x||e.min.x>=this.max.x||e.max.y<=this.min.y||e.min.y>=this.max.y)}clone(){return new me(u.clone(this.min),u.clone(this.max))}getCenter(){return new u((this.max.x+this.min.x)/2,(this.max.y+this.min.y)/2)}}var Wn=k(15649),Ae=k.n(Wn);const Vn=.1;class re{constructor(){this.boundingBoxMap=new Map,this.geoJSONMap=new Map}deleteBuildingOutlines(e){const{parts:t,outlines:n}=this.getPartsAndOutlinesFromAreas(e),r=new Set;for(const s of n){const i=this.getAreaGeoJSON(s),a=re.getMultiPolygonArea(i);for(const c of t)this.isBoundingBoxesIntersect(s,c)&&this.subtractPartFromOutline(s,c);re.getMultiPolygonArea(i)/a<Vn&&r.add(s)}return r.size===0?e:e.filter(s=>!r.has(s))}getPartsAndOutlinesFromAreas(e){return{outlines:e.filter(t=>t.descriptor.type==="building"),parts:e.filter(t=>t.descriptor.type==="buildingPart")}}getAreaBoundingBox(e){let t=this.boundingBoxMap.get(e);return t||(t=re.getVectorAreaBoundingBox(e),this.boundingBoxMap.set(e,t)),t}getAreaGeoJSON(e){let t=this.geoJSONMap.get(e);return t||(t=re.getVectorAreaGeoJSON(e),this.geoJSONMap.set(e,t)),t}isBoundingBoxesIntersect(e,t){const n=this.getAreaBoundingBox(e),r=this.getAreaBoundingBox(t);return n.intersectsAABB(r)}subtractPartFromOutline(e,t){const n=this.getAreaGeoJSON(e),r=this.getAreaGeoJSON(t);if(!(r.coordinates.length===0&&n.coordinates.length===0))try{const s=this.executePolygonDifference(n,r);s&&(n.coordinates=s.coordinates,n.type=s.type)}catch(s){re.logError(t.osmReference.id,e.osmReference.id),console.error(s)}}executePolygonDifference(e,t){const n=Ae().polygonFromGeoJSON(e),r=Ae().polygonFromGeoJSON(t);let s=null;try{s=Ae().difference(n,r)}catch(i){console.error(i)}if(s){const i=Ae().polygonToGeoJSON(s),a={type:"MultiPolygon",coordinates:[]};return i.type==="Polygon"&&a.coordinates.push(i.coordinates),i.type==="MultiPolygon"&&(a.coordinates=i.coordinates),a}return null}static logError(e,t){console.error(`Building-building:part intersection test failed for part \u2116${e} and outline \u2116${t}`)}static getMultiPolygonArea(e){let t=0;for(const n of e.coordinates)t+=re.getPolygonArea({type:"Polygon",coordinates:n});return t}static getPolygonArea(e){if(e.coordinates.length===0)return 0;const[t,...n]=e.coordinates;let r=re.getRingArea(t);for(const s of n)r-=re.getRingArea(s);return r}static getRingArea(e){let t=0;for(let n=0,r=e.length-1;n<e.length;r=n++){const[s,i]=e[n],[a,l]=e[r];t+=s*l-a*i}return Math.abs(t/2)}static getVectorAreaGeoJSON(e){const t={type:"MultiPolygon",coordinates:[]},n=[];for(const r of e.rings)r.type===W.Inner&&n.push(r);for(const r of e.rings)if(r.type===W.Outer){const s=[r.nodes.map(i=>[i.x,i.y])];for(let i=0;i<n.length;i++)s.push(n[i].nodes.map(a=>[a.x,a.y]));t.coordinates.push(s)}return t}static getVectorAreaBoundingBox(e){const t=new me;for(const n of e.rings)if(n.type===W.Outer)for(const r of n.nodes)t.includePoint(new u(r.x,r.y));return t}}const Le=.05,En=(o,e,t)=>{const n=[I.tile2degrees(o-Le,e+1+Le,t),I.tile2degrees(o+1+Le,e-Le,t)],r=n[0].lat+","+n[0].lon+","+n[1].lat+","+n[1].lon;return`
		[out:json][timeout:30];
		(
			node(${r});
			way(${r});
			rel["type"~"^(multipolygon|building)"](${r});
			//rel["type"="building"](br); // this is SLOW
			
			// Make sure that we have all parts of each building in the result
			(
				relation["building"](${r});
				>;
				way["building"](${r});
			) ->.buildingOutlines;
			way["building:part"](area.buildingOutlines);
			
			// Make sure that each powerline node knows about all the powerline segments it is connected to
			//way[power=line](${r})->.powerline;
			//way(around.powerline:0)[power=line];
		);
		
		out body qt;
		>>;
		out body qt;
	`};class Se extends st{constructor(e){super(),this.overpassURL=e}async getCollection({x:e,y:t,zoom:n}){const r=I.tile2meters(e,t+1,n),s=await Se.fetchOverpassTile(e,t,n,this.overpassURL),i=new Map,a=new Map,l=new Map,c=Se.classifyElements(s.elements);for(const p of c.nodes){const g=u.sub(I.degrees2meters(p.lat,p.lon),r),m=new qe(p,g.x,g.y);i.set(p.id,m)}for(const p of c.ways){const g=p.nodes.map(x=>i.get(x)),m=new Hn(p,g);a.set(p.id,m)}const d=new Map;for(const p of c.relations){const g=p.members.filter(x=>x.type==="way"||x.type==="relation");if(g.length===0)continue;const m=new Be(p);l.set(p.id,m),d.set(m,g)}for(const p of l.values()){const g=d.get(p);for(const m of g){const x=m.ref;let y;switch(m.type){case"way":y=a.get(x);break;case"relation":y=l.get(x);break}if(!y){console.error();continue}p.addMember(m,y)}}const h=Se.getFeaturesFromHandlers([...i.values(),...a.values(),...l.values()]),f=ot(h);return f.areas=new re().deleteBuildingOutlines(f.areas),f}static getFeaturesFromHandlers(e){const t=[];for(const n of e)t.push(...n.getFeatures());return t}static async fetchOverpassTile(e,t,n,r){return await(await fetch(r,{method:"POST",body:En(e,t,n)})).json()}static classifyElements(e){const t=[],n=[],r=[];for(const s of e)switch(s.type){case"node":t.push(s);break;case"way":n.push(s);break;case"relation":r.push(s);break}return{nodes:t,ways:n,relations:r}}}var ie;(o=>{let e;(t=>{t[t.Point=0]="Point",t[t.LineString=1]="LineString",t[t.Polygon=2]="Polygon"})(e=o.FeatureType||(o.FeatureType={}))})(ie||(ie={}));var B=(o=>(o[o.String=0]="String",o[o.Float=1]="Float",o[o.Double=2]="Double",o[o.Int=3]="Int",o[o.UInt=4]="UInt",o[o.SInt=5]="SInt",o[o.Bool=6]="Bool",o))(B||{});class qn{static decode(e,t,n){const r=new Map;for(const s of e.layers){const i={features:[]},a=s.keys,l=s.values;for(const c of s.features){const d=this.decodeFeature(c,a,l,t,s.extent,n);i.features.push(d)}r.set(s.name,i)}return{layers:r}}static decodeFeature(e,t,n,r,s,i){switch(e.type){case 1:return{id:e.id,type:ie.FeatureType.Point,tags:this.decodeTags(e.tags,t,n,r),geometry:U.convertCommandsToPoints(e.geometry,s,i)};case 2:return{id:e.id,type:ie.FeatureType.LineString,tags:this.decodeTags(e.tags,t,n,r),geometry:U.convertCommandsToLineString(e.geometry,s,i)};case 3:return{id:e.id,type:ie.FeatureType.Polygon,tags:this.decodeTags(e.tags,t,n,r),geometry:U.convertCommandsToPolygon(e.geometry,s,i)}}throw new Error(`Unknown feature type: ${e.type}`)}static decodeTags(e,t,n,r){const s={};for(let i=0;i<e.length;i+=2){const a=t[e[i]],l=n[e[i+1]],c=r[a];if(c===void 0){console.warn(`Unknown tag key: ${a}`,l);continue}s[a]=this.decodeTagValue(l,c)}return s}static decodeTagValue(e,t){switch(t){case 0:return e.string_value;case 1:return e.float_value;case 2:return e.double_value;case 3:return e.int_value;case 4:return e.uint_value;case 5:return e.sint_value;case 6:return e.bool_value}throw new Error(`Unknown tag type: ${t}`)}}const _n={soccer:"football",tennis:"tennis",basketball:"basketball"};function jn(o,e){const t=_n[o];return t==="basketball"&&e===1?"generic":t??"generic"}const Un={flat:"flat",hipped:"hipped",gabled:"gabled",gambrel:"gambrel",pyramidal:"pyramidal",onion:"onion",dome:"dome",round:"round",skillion:"skillion",mansard:"mansard",quadruple_saltbox:"quadrupleSaltbox",saltbox:"saltbox"};function Xn(o,e="flat"){return Un[o]??e}const Yn=["roof","stadium","houseboat","castle","greenhouse","storage_tank","silo","stadium","ship","bridge","digester","water_tower","shed"];function $n(o){const e=o.defaultRoof;return e!==void 0?e:!Yn.includes(o.buildingType)}const Jn={tile:"tiles",tiles:"tiles",roof_tiles:"tiles",slate:"tiles",metal:"metal",metal_sheet:"metal","metal sheet":"metal",tin:"metal",copper:"metal",zinc:"metal",concrete:"concrete",asphalt:"concrete",eternit:"eternit",asbestos:"eternit",thatch:"thatch",grass:"grass",glass:"glass",tar_paper:"tar"};function Zn(o,e="concrete"){return Jn[o]??e}function Qn(o){const e=Xn(o.roofType,"flat"),t=!$n(o)||e!=="flat",n=o.roofMaterial,r=o.roofColor;let s=Zn(n,"default"),i=r??null;if((i!==null||t)&&s==="default"&&(s="concrete"),i===null)switch(s){case"concrete":{i=12303291;break}case"metal":{i=n==="copper"?10734269:12833501;break}case"tiles":{i=n==="slate"?9211031:13335908;break}default:i=16777215}return{type:e,material:s,color:i}}function Kn(o){return o==="along"||o==="across"?o:null}const er=["garage","garages","greenhouse","storage_tank","bunker","silo","stadium","ship","castle","service","digester","water_tower","shed","ger","barn","slurry_tank","container","carport"];function tr(o){const e=o.windows;return e!==void 0?e:!er.includes(o.buildingType)}const Mt={brick:{type:"brick",defaultColor:9193524},cement_block:{type:"cementBlock",defaultColor:16777215},block:{type:"cementBlock",defaultColor:16777215},wood:{type:"wood",defaultColor:16777215},plaster:{type:"plaster",defaultColor:16777215},plastered:{type:"plaster",defaultColor:16777215},concrete:{type:"plaster",defaultColor:14540253},hard:{type:"plaster",defaultColor:14540253},glass:{type:"glass",defaultColor:16777215},mirror:{type:"glass",defaultColor:16777215}};function nr(o){const e=o.material,t=o.color,n=Mt[e]??Mt.plaster,r=t??n.defaultColor;return{material:n.type,color:r}}function rr(o){const n=o.buildingType==="roof",r=!n&&o.levels===void 0&&o.minLevel===void 0&&o.height===void 0&&o.minHeight===void 0,s=Qn(o),i=Kn(o.roofOrientation),a=o.roofLevels<=0?.6:o.roofLevels??(s.type==="flat"?0:1),l=o.roofDirection??null,c=o.roofAngle??null;let d=o.roofHeight??a*4,h=o.minLevel??null,f=o.height??null,p=o.levels??null,g=o.minHeight??null;f!==null&&(d=Math.min(d,f-(g??0))),f===null&&p===null?(p=h!==null?h:1,f=p*4+d):f===null?f=p*4+d:p===null&&(p=Math.max(1,Math.round((f-d)/4))),h===null&&(g!==null?h=Math.min(p-1,Math.round(g/4)):h=0),g===null&&(g=Math.min(h*4,f));const m=nr(o),x=o.name??null;let y=tr(o);return f-g-d<2&&(y=!1),{label:x,buildingLevels:p-h,buildingHeight:f,buildingMinHeight:n?f-d:g,buildingRoofHeight:d,buildingRoofType:s.type,buildingRoofOrientation:i,buildingRoofDirection:l,buildingRoofAngle:c,buildingFacadeMaterial:m.material,buildingFacadeColor:m.color,buildingRoofMaterial:s.material,buildingRoofColor:s.color,buildingWindows:y,buildingFoundation:r}}const sr={beech:"beech",fagus:"beech",fir:"fir",abies:"fir",linden:"linden",tilia:"linden",linde:"linden",oak:"oak",quercus:"oak"};function _e(o){const e=o.genus,t=sr[e];return t||(o.leafType==="needleleaved"?"genericNeedleleaved":"genericBroadleaved")}class xe extends ge{static isTagsContainOMBB(e){return e["@ombb00"]!==void 0}static getOMBB(e){return this.isTagsContainOMBB(e)?[new u(e["@ombb00"],e["@ombb01"]),new u(e["@ombb10"],e["@ombb11"]),new u(e["@ombb20"],e["@ombb21"]),new u(e["@ombb30"],e["@ombb31"])]:null}static isTagsContainPOI(e){return e["@poiX"]!==void 0}static getPOI(e){return new w(e["@poiX"],e["@poiY"],e["@poiR"])}fromTags(e){return e.type==="building"?e.buildingType==="construction"?[{type:b.Descriptor,data:{type:"buildingConstruction"}}]:[{type:b.Descriptor,data:{type:"building",...rr(e),ombb:xe.getOMBB(e)}}]:e.type==="path"?e.pathType==="pedestrian"||e.pathType==="footway"?[{type:b.Descriptor,data:{type:"pavement"}}]:[{type:b.Descriptor,data:{type:"asphalt"}}]:e.type==="water"?[{type:b.Descriptor,data:{type:"water"}}]:e.type==="forest"?[{type:b.Descriptor,data:{type:"forest",treeType:_e(e)}}]:e.type==="sand"?[{type:b.Descriptor,data:{type:"sand"}}]:e.type==="rock"?[{type:b.Descriptor,data:{type:"rock"}}]:e.type==="playground"||e.type==="dogPark"?[{type:b.Descriptor,data:{type:"pitch",pitchType:"generic"}}]:e.type==="pitch"?[{type:b.Descriptor,data:{type:"pitch",pitchType:jn(e.sport,e.hoops),ombb:xe.getOMBB(e)}}]:e.type==="fairway"?[{type:b.Descriptor,data:{type:"manicuredGrass"}}]:e.type==="garden"?[{type:b.Descriptor,data:{type:"garden"}}]:e.type==="grass"?[{type:b.Descriptor,data:{type:"grass"}}]:e.type==="farmland"?[{type:b.Descriptor,data:{type:"farmland",ombb:xe.getOMBB(e)}}]:e.type==="scrub"?[{type:b.Descriptor,data:{type:"shrubbery"}}]:e.type==="construction"||e.type==="brownfield"?[{type:b.Descriptor,data:{type:"construction",poi:xe.getPOI(e)}}]:e.type==="parking"?[{type:b.Descriptor,data:{type:"asphalt"}}]:e.type==="bridge"||e.type==="apron"?[{type:b.Descriptor,data:{type:"pavement"}}]:e.type==="helipad"?[{type:b.Descriptor,data:{type:"helipad"}}]:e.type==="pier"?[{type:b.Descriptor,data:{type:"pavement"}}]:null}}class ke{constructor(e){this.rings=[],this.tags=e.tags,this.osmReference=We(this.tags);for(const t of e.geometry)this.addRing(t)}addRing(e){if(!ke.validateRing(e))throw new Error("Invalid PBF ring");const t=ke.inputRingToVectorRing(e);this.rings.push(t)}getFeatures(){const e=[],t=new xe().fromTags(this.tags);if(!t)return[];for(const n of t)n.type===b.Descriptor&&e.push(...this.getVectorAreasFromRings(n.data));return e}getVectorAreasFromRings(e){const t=[];for(const n of this.rings)if(n.type===W.Outer)t.push({type:"area",rings:[n],osmReference:this.osmReference,descriptor:{...e}});else{if(!t[t.length-1])throw new Error("Invalid ring order");t[t.length-1].rings.push(n)}return t}static isRingClockwise(e){let t=0;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1]??e[0];t+=(s[0]-r[0])*(s[1]+r[1])}return t<0}static validateRing(e){const t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]}static inputRingToVectorRing(e){const n=ke.isRingClockwise(e)?W.Outer:W.Inner,r=e.map(([s,i])=>({type:"node",x:s,y:i,rotation:0,osmReference:null,descriptor:null}));return{type:n,nodes:r}}}const or={asphalt:"asphalt",unpaved:"dirt",paved:"asphalt",ground:"dirt",concrete:"concrete",paving_stones:"cobblestone",gravel:"dirt",dirt:"dirt",grass:"dirt",compacted:"dirt",sand:"sand",sett:"cobblestone",fine_gravel:"dirt",wood:"wood",cobblestone:"cobblestone",earth:"dirt",pebblestone:"cobblestone"},ir={residential:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},service:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!1},track:{type:"roadway",defaultMaterial:"dirt",defaultLanes:1,defaultIsMarked:!1},unclassified:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},tertiary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},secondary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},primary:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},living_street:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!1},trunk:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},motorway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:2,defaultIsMarked:!0},motorway_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},trunk_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},primary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},secondary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},tertiary_link:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},busway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultIsMarked:!0},raceway:{type:"roadway",defaultMaterial:"asphalt",defaultLanes:1,defaultWidth:6,defaultIsMarked:!1},footway:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},path:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},steps:{type:"footway",defaultMaterial:"dirt",defaultLanes:1},pedestrian:{type:"footway",defaultMaterial:"dirt",defaultLanes:1,defaultWidth:8},cycleway:{type:"cycleway",defaultMaterial:"dirt",defaultLanes:1}};function ar(o){const e=ir[o.pathType];if(!e)return null;const t=or[o.surface]??e.defaultMaterial;return{type:e.type,material:t,defaultLanes:e.defaultLanes??1,defaultWidth:e.defaultWidth,defaultIsMarked:e.defaultIsMarked??!0}}function lr(o,e){const t=!!o.oneway;let n=o.lanesForward,r=o.lanesBackward;const s=o.lanes??(t?Math.max(1,Math.floor(e/2)):e);return t?(n=s,r=0):n===void 0&&r===void 0?(n=Math.ceil(s/2),r=s-n):n===void 0?n=Math.max(0,s-r):r===void 0&&(r=Math.max(0,s-n)),{forward:n,backward:r}}function cr(o,e,t,n){const r=o.width;if(r!==void 0)return r;if(n!==void 0)return n;const s=e+t;return s===1?4:s*3}const ur={river:10,stream:2,canal:8,drain:1,ditch:1};function dr(o){const e=ur[o.waterwayType];return e===void 0?null:{width:o.width??e}}function vt(o){switch(o){case 0:return"left";case 1:return"right";case 2:return"both"}return null}const St={hedge:{type:"hedge",defaultHeight:1},dry_stone:{type:"stone",defaultHeight:3},stone:{type:"stone",defaultHeight:3},brick:{type:"stone",defaultHeight:3},concrete:{type:"concrete",defaultHeight:3},concrete_block:{type:"concrete",defaultHeight:3}};function hr(o){const e=o.wallType,t=St[e]??St.concrete;return{material:t.type,height:o.height??t.defaultHeight,minHeight:o.minHeight}}const kt={wood:{type:"wood",defaultHeight:2},chain_link:{type:"chainLink",defaultHeight:3},wire:{type:"chainLink",defaultHeight:3},metal:{type:"metal",defaultHeight:1.5},railing:{type:"metal",defaultHeight:1.5},concrete:{type:"concrete",defaultHeight:2.5}};function fr(o){const e=o.fenceType,t=kt[e]??kt.metal;return{material:t.type,height:o.height??t.defaultHeight,minHeight:o.minHeight}}function pr(o){return o===void 0||o.length===0?[]:o.split(";").map(e=>e.trim().toLowerCase())}const Tt={rail:{type:"railway",gauge:1435},light_rail:{type:"railway",gauge:1435},subway:{type:"railway",gauge:1435},disused:{type:"railway",gauge:1435},narrow_gauge:{type:"railway",gauge:1e3},tram:{type:"tramway",gauge:1435}},It={broad:1676,standard:1435,narrow:1e3};function gr(o,e){const t=pr(o);let n=e;if(t.length>0){const r=t.map(s=>It[s]!==void 0?It[s]:parseInt(s)).filter(s=>!isNaN(s));r.length>0&&(n=Math.max(...r))}return n}function yr(o){const e=Tt[o.railwayType]??Tt.rail,t=gr(o.gauge,e.gauge);return{type:e.type,width:t/1e3}}function we(o){const e=o.minHeight??0;let t=o.height??void 0;return t!==void 0&&e!==0&&(t-=e,t=Math.max(t,0)),[t,e]}class mr extends ge{fromTags(e){if(e.type==="path"){switch(e.pathType){case"runway":case"taxiway":{const n=e.width??(e.pathType==="runway"?45:20);return[{type:b.Descriptor,data:{type:"path",pathType:"runway",width:n}}]}}const t=ar(e);if(!t)return null;switch(t.type){case"roadway":{const n=[],r=lr(e,t.defaultLanes),s=cr(e,r.forward,r.backward,t.defaultWidth),i=e.laneMarkings??t.defaultIsMarked;n.push({type:b.Descriptor,data:{type:"path",pathType:"roadway",pathMaterial:t.material,lanesForward:r.forward,lanesBackward:r.backward,width:s,isRoadwayMarked:i}});const a=vt(e.sidewalkSide),l=vt(e.cyclewaySide),c=2,d=2;if(l&&n.push({type:b.Descriptor,data:{type:"path",pathType:"cycleway",width:s+c*2,side:l}}),a)if(!l||l==="both")n.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:s+d*2+(l==="both"?c*2:0),side:a}});else{if(a==="left"||a==="both"){const h=l==="left"?1:0,f=s+d*2+h*c*2;n.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:f,side:"left"}})}if(a==="right"||a==="both"){const h=l==="right"?1:0,f=s+d*2+h*c*2;n.push({type:b.Descriptor,data:{type:"path",pathType:"footway",width:f,side:"right"}})}}return n}case"footway":return[{type:b.Descriptor,data:{type:"path",pathType:"footway",width:e.width??t.defaultWidth??2}}];case"cycleway":return[{type:b.Descriptor,data:{type:"path",pathType:"cycleway",width:e.width??t.defaultWidth??3}}]}}if(e.type==="railway"){const{type:t,width:n}=yr(e);return[{type:b.Descriptor,data:{type:"path",pathType:t,width:n}}]}if(e.type==="treeRow"){const[t,n]=we(e);return[{type:b.Modifier,data:{type:ne.NodeRow,spacing:10,randomness:1,descriptor:{type:"tree",height:t,minHeight:n,treeType:_e(e)}}}]}if(e.type==="waterway"){const t=dr(e);return t?[{type:b.Descriptor,data:{type:"waterway",width:t.width}}]:null}if(e.type==="wall"){const t=hr(e);return[{type:b.Descriptor,data:{type:"wall",wallType:t.material,height:t.height,minHeight:t.minHeight}}]}if(e.type==="fence"){const t=fr(e);return[{type:b.Descriptor,data:{type:"fence",fenceMaterial:t.material,height:t.height,minHeight:t.minHeight}}]}return null}}class xr{constructor(e){this.tags=e.tags,this.osmReference=We(this.tags),this.geometry=e.geometry}getFeatures(){const e=[],t=new mr().fromTags(this.tags);if(!t)return e;for(const n of t)if(n.type===b.Descriptor)for(let r=0;r<this.geometry.length;r++)e.push(this.getVectorPolylineFromGeometry(r,n.data));else if(n.type===b.Modifier){const r=n.data;if(r.type===ne.NodeRow)for(let s=0;s<this.geometry.length;s++){const a=new Pe(this.getVectorNodesFromGeometry(s),W.Outer).distributeNodes(r.spacing,r.randomness,r.descriptor);e.push(...a)}else console.error(`Unexpected modifier ${r.type}`);break}return e}getVectorPolylineFromGeometry(e,t){const n=this.getVectorNodesFromGeometry(e);return{type:"polyline",osmReference:this.osmReference,descriptor:{...t},nodes:n}}getVectorNodesFromGeometry(e){return this.geometry[e].map(([n,r])=>({type:"node",x:n,y:r,rotation:0,osmReference:null,descriptor:null}))}}class wr extends ge{fromTags(e){if(e.type==="tree"){const[t,n]=we(e);return[{type:b.Descriptor,data:{type:"tree",height:t,minHeight:n,treeType:_e(e)}}]}if(e.type==="fireHydrant")return[{type:b.Descriptor,data:{type:"hydrant",height:e.height??void 0,minHeight:e.minHeight??void 0}}];if(e.type==="adColumn")return[{type:b.Descriptor,data:{type:"adColumn",height:e.height??void 0,minHeight:e.minHeight??void 0}}];if(e.type==="memorial"){const[t,n]=we(e);return[{type:b.Descriptor,data:{type:"memorial",height:t,minHeight:n,direction:e.direction??void 0}}]}if(e.type==="statue"){const[t,n]=we(e);return[{type:b.Descriptor,data:{type:"statue",height:t,minHeight:n,direction:e.direction??void 0}}]}if(e.type==="sculpture"){const[t,n]=we(e);return[{type:b.Descriptor,data:{type:"sculpture",height:t,minHeight:n,direction:e.direction??void 0}}]}if(e.type==="windTurbine"){const[t,n]=we(e);return[{type:b.Descriptor,data:{type:"windTurbine",height:t,minHeight:n}}]}return e.type==="bench"?[{type:b.Descriptor,data:{type:"bench",minHeight:e.minHeight??void 0,direction:e.direction??void 0}}]:e.type==="picnicTable"?[{type:b.Descriptor,data:{type:"picnicTable",minHeight:e.minHeight??void 0,direction:e.direction??void 0}}]:e.highway==="roundabout"?[{type:b.Modifier,data:{type:ne.CircleArea,radius:10,descriptor:{type:"roadwayIntersection",intersectionMaterial:"asphalt"}}}]:e.type==="busStop"?[{type:b.Descriptor,data:{type:"busStop",minHeight:e.minHeight??void 0,direction:e.direction??void 0}}]:e.type==="helipad"?[{type:b.Modifier,data:{type:ne.CircleArea,radius:8,descriptor:{type:"helipad"}}}]:e.type==="rock"?[{type:b.Descriptor,data:{type:"rock",height:e.height??void 0,minHeight:e.minHeight??void 0}}]:null}}class br{constructor(e){this.tags=e.tags,this.osmReference=We(this.tags),this.x=e.geometry[0][0],this.y=e.geometry[0][1]}getFeatures(){const e=[],t=new wr().fromTags(this.tags);if(!t)return[];for(const n of t)n.type===b.Descriptor?e.push({type:"node",x:this.x,y:this.y,rotation:0,osmReference:this.osmReference,descriptor:n.data}):(n.type,b.Modifier);return e}}var Ft=(o=>(o[o.Linear=0]="Linear",o[o.Logarithmic=1]="Logarithmic",o))(Ft||{});const J={TileSize:611.4962158203125,MaxConcurrentTiles:150,MaxTilesPerWorker:1,WorkersCount:Math.min(4,navigator.hardwareConcurrency),StartPosition:{lat:40.76494,lon:-73.9786,pitch:45,yaw:0,distance:2e3},MinCameraDistance:10,MaxCameraDistance:4e3,SlippyMapTransitionDuration:400,MinFreeCameraHeight:10,CameraZoomSmoothing:.4,CameraZoomSpeed:5e-4,CameraZoomTrackpadFactor:4,MinCameraPitch:5,MaxCameraPitch:89.99,MinFreeCameraPitch:-89.99,MaxFreeCameraPitch:89.99,GroundCameraSpeed:400,GroundCameraSpeedFast:1200,FreeCameraSpeed:400,FreeCameraSpeedFast:1200,FreeCameraRotationSensitivity:2e-5,FreeCameraYawSpeed:.8,FreeCameraPitchSpeed:.8,MinTexturedRoofArea:50,MaxTexturedRoofAABBArea:2e6,BuildingSmoothNormalsThreshold:30,LightTransitionDuration:1,OverpassRequestTimeout:3e4,CameraFOVZoomFactor:2,CSMShadowCameraNear:1,CSMShadowCameraFar:2e4,TerrainRingCount:6,TerrainRingSegmentCount:64,TerrainRingSizeZoom:13,TerrainRingSize:4007501668e-2/(1<<13),TerrainMaskResolution:32,TerrainNormalMixRange:[1e4,14500],TerrainUsageTextureSize:512,TerrainUsageTexturePadding:3,TerrainUsageSDFPasses:3,TerrainDetailUVScale:64,SlippyMapMinZoom:0,SlippyMapMaxZoom:16,SlippyMapZoomFactor:.001,SlippyMapFetchBatchSize:4,SettingsSchema:{fov:{label:"Vertical field of view",selectRange:[5,120,1],selectRangeDefault:40,category:"general"},labels:{label:"Text labels",status:["off","on"],statusLabels:["Disabled","Enabled"],statusDefault:"on",category:"general"},terrainHeight:{label:"Use terrain elevation data",status:["off","on"],statusLabels:["Disabled","Enabled"],statusDefault:"on",category:"general"},shadows:{label:"Shadows",status:["off","low","medium","high"],statusLabels:["Disabled","Low","Medium","High"],statusDefault:"medium",category:"graphics"},taa:{label:"TAA",status:["off","on"],statusLabels:["Disabled","Enabled"],statusDefault:"on",category:"graphics"},dof:{label:"Depth of field",status:["off","low","high"],statusLabels:["Disabled","Low quality","High quality"],statusDefault:"off",category:"graphics"},dofAperture:{label:"Aperture",parent:"dof",parentStatusCondition:["low","high"],selectRange:[.001,1,.001],selectRangeDefault:.01,selectRangeScale:Ft.Logarithmic,category:"graphics"},dofMode:{label:"Focusing mode",parent:"dof",parentStatusCondition:["low","high"],status:["center","cursor"],statusLabels:["Screen center","Cursor position"],statusDefault:"center",category:"graphics"},bloom:{label:"Bloom",status:["off","on"],statusLabels:["Disabled","Enabled"],statusDefault:"on",category:"graphics"},ssr:{label:"Screen-space reflections",status:["off","low","high"],statusLabels:["Disabled","Low quality","High quality"],statusDefault:"off",category:"graphics"},ssao:{label:"Screen-space ambient occlusion",status:["off","on"],statusLabels:["Disabled","Enabled"],statusDefault:"on",category:"graphics"}},OverpassEndpoints:[{url:"https://overpass-api.de/api/interpreter",isEnabled:!0},{url:"https://overpass.openstreetmap.ru/cgi/interpreter",isEnabled:!1},{url:"https://overpass.kumi.systems/api/interpreter",isEnabled:!1}],TileServerEndpoint:"https://tiles.streets.gl",SlippyEndpointTemplate:"https://tile.openstreetmap.org/{z}/{x}/{y}.png",TilesEndpointTemplate:"https://tiles.streets.gl/vector/{z}/{x}/{y}"},Mr=k(53434).n,vr={"@ombb00":B.Double,"@ombb01":B.Double,"@ombb10":B.Double,"@ombb11":B.Double,"@ombb20":B.Double,"@ombb21":B.Double,"@ombb30":B.Double,"@ombb31":B.Double,"@poiX":B.Double,"@poiY":B.Double,"@poiR":B.Double,type:B.String,osmId:B.SInt,osmType:B.SInt,name:B.String,width:B.Double,height:B.Double,minHeight:B.Double,roofHeight:B.Double,buildingType:B.String,wallType:B.String,pathType:B.String,cyclewaySide:B.SInt,sidewalkSide:B.SInt,surface:B.String,lanes:B.SInt,lanesForward:B.SInt,lanesBackward:B.SInt,oneway:B.Bool,levels:B.SInt,minLevel:B.SInt,roofLevels:B.SInt,roofShape:B.String,windows:B.Bool,defaultRoof:B.Bool,color:B.SInt,material:B.String,roofMaterial:B.String,roofColor:B.SInt,roofType:B.String,roofAngle:B.Double,roofOrientation:B.String,roofDirection:B.Double,laneMarkings:B.String,gauge:B.String,fenceType:B.String,leafType:B.String,genus:B.String,direction:B.Double,waterwayType:B.String,sport:B.String,hoops:B.SInt,railwayType:B.String,crop:B.String,country:B.String,wikidata:B.String,isPart:B.Bool,lampSupport:B.String};class be{constructor(){}async getCollection({x:e,y:t,zoom:n}){const r=await be.fetchTile(e,t,n),s=be.getVectorTileHandlers(r),i=be.getFeaturesFromHandlers(s);return ot(i)}static async fetchTile(e,t,n){const r=4007501668e-2/(1<<n),s=be.getTileURL(e,t,n),i=await fetch(s,{method:"GET"});if(i.status!==200)throw new Error(`Failed to fetch tile: ${i.status}`);const a=new(rt())(await i.arrayBuffer()),l=Mr.read(a);return qn.decode(l,vr,r)}static getTileURL(e,t,n){return V.resolveEndpointTemplate({template:J.TilesEndpointTemplate,values:{x:e,y:t,z:n}})}static getVectorTileHandlers(e){const t=[];for(const n of e.layers.values())for(const r of n.features)switch(r.type){case ie.FeatureType.Polygon:{t.push(new ke(r));break}case ie.FeatureType.LineString:{t.push(new xr(r));break}case ie.FeatureType.Point:{t.push(new br(r));break}}return t}static getFeaturesFromHandlers(e){const t=[];for(const n of e)t.push(...n.getFeatures());return t}}class Sr extends st{constructor(e){super(),this.overpassProvider=new Se(e.overpassEndpoint),this.mapboxProvider=new Ne(e.vectorTilesEndpointTemplate),this.pbfProvider=new be}async getCollection({x:e,y:t,zoom:n}){const r=this.pbfProvider.getCollection({x:e,y:t,zoom:n});return new Promise((s,i)=>{r.then(a=>{s(a)}).catch(a=>{i(a)})})}mergeCollections(...e){return{nodes:[].concat(...e.map(t=>t.nodes)),polylines:[].concat(...e.map(t=>t.polylines)),areas:[].concat(...e.map(t=>t.areas))}}clearFeaturesNotInTile(e,t,n,r){const s=I.tile2meters(0,0,16).x-I.tile2meters(1,1,16).x;for(let i=0;i<e.areas.length;i++){const a=e.areas[i];a.descriptor.type==="building"&&!this.isAreaInTile(a,s)&&(e.areas.splice(i,1),i--)}}isAreaInTile(e,t){for(const n of e.rings)for(const r of n.nodes)if(r.x>=0&&r.x<=t&&r.y>=0&&r.y<=t)return!0;return!1}}class ae{constructor(e){this.seed=e||49734321}generate(){return this.seed=this.seed+2127912214+(this.seed<<12)&4294967295,this.seed=(this.seed^3345072700^this.seed>>>19)&4294967295,this.seed=this.seed+374761393+(this.seed<<5)&4294967295,this.seed=(this.seed+3550635116^this.seed<<9)&4294967295,this.seed=this.seed+4251993797+(this.seed<<3)&4294967295,this.seed=(this.seed^3042594569^this.seed>>>16)&4294967295,(this.seed&268435455)/268435456}}function kr(o,e,t,n){const r=I.getMercatorScaleFactorForTile(e,t,n);for(const s of o){s.boundingBox.min.y*=r,s.boundingBox.max.y*=r;for(let i=1;i<s.positionBuffer.length;i+=3)s.positionBuffer[i]*=r}}function Tr(o,e){o=Math.min(8,o),e=Math.min(8,e);const s=-o,i=e,a=s*.125+.5,l=i*.125+.5;return{minX:a+.00625,maxX:l-.00625}}function Ir(o){const e=[o.extruded.positionBuffer.buffer,o.extruded.uvBuffer.buffer,o.extruded.normalBuffer.buffer,o.extruded.textureIdBuffer.buffer,o.extruded.colorBuffer.buffer,o.extruded.idBuffer.buffer,o.extruded.offsetBuffer.buffer,o.extruded.localIdBuffer.buffer,o.projected.positionBuffer.buffer,o.projected.normalBuffer.buffer,o.projected.uvBuffer.buffer,o.projected.textureIdBuffer.buffer,o.hugging.positionBuffer.buffer,o.hugging.normalBuffer.buffer,o.hugging.uvBuffer.buffer,o.hugging.textureIdBuffer.buffer,o.terrainMask.positionBuffer.buffer,o.labels.position.buffer,o.labels.priority.buffer];for(const t of Object.values(o.instances))e.push(t.interleavedBufferLOD0.buffer),e.push(t.interleavedBufferLOD1.buffer);return e}function Rt(o){const e={beech:[0],fir:[1],linden:[2,3],oak:[4],genericBroadleaved:[0,2,3,4],genericNeedleleaved:[1]};return e[o]??e.genericBroadleaved}function Pt(o){return{0:[14,18],1:[25,35],2:[14,18],3:[14,18],4:[12,15]}[o]}function Bt(o){return{0:1.35,1:1.06,2:1.19,3:1.02,4:1.43}[o]}const At=611.4962158203125;class Fr{constructor(e){this.mercatorScale=1,this.terrainHeight=0,this.graph=null,this.osmReference=e.osmReference,this.descriptor=e.descriptor,this.x=e.x,this.y=e.y}setRoadGraph(e){this.graph=e}setMercatorScale(e){this.mercatorScale=e}getFeatures(){if(this.isOutOfBounds())return[];if(this.descriptor.type==="tree")return[this.getTreeInstanceFeature({height:this.descriptor.height,minHeight:this.descriptor.minHeight})];if(this.descriptor.type==="adColumn")return[this.getGenericInstanceFeature({type:"adColumn",rotateToNearestPath:!1})];if(this.descriptor.type==="hydrant")return[this.getGenericInstanceFeature({type:"hydrant",minHeight:this.descriptor.minHeight,rotateToNearestPath:!1})];if(this.descriptor.type==="windTurbine")return[this.getGenericInstanceFeature({type:"windTurbine",rotateToNearestPath:!1,height:this.descriptor.height,minHeight:this.descriptor.minHeight,rotation:0})];if(this.descriptor.type==="bench")return[this.getGenericInstanceFeature({type:"bench",rotateToNearestPath:!0,rotation:this.descriptor.direction})];if(this.descriptor.type==="picnicTable")return[this.getGenericInstanceFeature({type:"picnicTable",rotateToNearestPath:!0})];if(this.descriptor.type==="busStop")return[this.getGenericInstanceFeature({type:"busStop",rotateToNearestPath:!0,pathGroupId:0})];if(this.descriptor.type==="memorial")return[this.getGenericInstanceFeature({type:"memorial",minHeight:this.descriptor.minHeight,rotateToNearestPath:!0})];if(this.descriptor.type==="statue"){const e=new ae(Math.floor(this.x+this.y));return[this.getGenericInstanceFeature({type:e.generate()>.5?"statueSmall":"statueBig",minHeight:this.descriptor.minHeight,rotateToNearestPath:!0})]}return this.descriptor.type==="sculpture"?[this.getGenericInstanceFeature({type:"sculpture",minHeight:this.descriptor.minHeight,rotateToNearestPath:!0})]:[]}getGenericInstanceFeature({type:e,rotateToNearestPath:t=!1,pathGroupId:n,height:r=1,minHeight:s,rotation:i}){let a=0;if(i!==void 0)a=-I.toRad(i)+Math.PI*.5;else if(t&&this.graph){const c=new u(this.x,this.y),d=this.graph.getClosestProjection(c,n);d&&(a=-u.sub(d,c).getAngle()+Math.PI*.5)}else a=new ae(Math.floor(this.x+this.y)).generate()*Math.PI*2;const l=s??0;return{type:"instance",instanceType:e,x:this.x,y:this.terrainHeight+l*this.mercatorScale,z:this.y,scale:r*this.mercatorScale,rotation:a}}getTreeInstanceFeature({height:e,minHeight:t}){const n=new ae(Math.floor(this.x+this.y)),r=n.generate()*Math.PI*2,s=Rt(this.descriptor.treeType),i=s[Math.floor(n.generate()*s.length)],a=Bt(i);if(e===void 0){const c=Pt(i);e=c[0]+n.generate()*(c[1]-c[0])}const l=t??0;return{type:"instance",instanceType:"tree",x:this.x,y:this.terrainHeight+l*this.mercatorScale,z:this.y,scale:e*a*this.mercatorScale,rotation:r,textureId:i,seed:n.generate()}}getRequestedHeightPositions(){return this.isOutOfBounds()?null:this.descriptor.type?{positions:new Float64Array([this.x,this.y]),callback:e=>{this.terrainHeight=e[0]*this.mercatorScale}}:null}isOutOfBounds(){return this.x<0||this.x>At||this.y<0||this.y>At}}const z={Water:0,Grass:1,Sand:2,Rock:3,ManicuredGrass:4,Garden:5,Construction:6,Farmland:7,Waterway:8,Pitch:9,ShrubberySoil:10,Railway:11,RailwayOverlay:12,DirtRoadway:13,SandRoadway:14,RoadwayArea:15,Footway:16,WoodFootway:17,AsphaltFootway:17,FootwayArea:18,Cycleway:19,AsphaltRoadway:20,ConcreteRoadway:21,WoodRoadway:22,CobblestoneRoadway:23,AsphaltArea:24,ConcreteArea:25,CobblestoneArea:26,Runway:27,Rail:28,Helipad:29};var j=(o=>(o[o.Outer=0]="Outer",o[o.Inner=1]="Inner",o))(j||{});class Lt{constructor(e,t){this.cachedFlattenVertices=null,this.cachedGeoJSONVertices=null,this.cachedAABB=null,this.cachedArea=null,this.type=e,this.nodes=t}getFlattenVertices(){if(!this.cachedFlattenVertices){const e=[];for(const t of this.nodes)e.push(t.x,t.y);this.cachedFlattenVertices=e}return this.cachedFlattenVertices}getGeoJSONVertices(){if(!this.cachedGeoJSONVertices){const e=[];for(const t of this.nodes)e.push([t.x,t.y]);this.cachedGeoJSONVertices=e}return this.cachedGeoJSONVertices}getAABB(){if(!this.cachedAABB){const e=new me;for(const t of this.nodes)e.includePoint(t);this.cachedAABB=e}return this.cachedAABB}getDistanceToPoint(e){let t=1/0;for(const n of this.nodes){const r=u.distance(n,e);r<t&&(t=r)}return t}isContainsPoints(e){return I.isPointInsidePolygon(e,this.nodes)}getArea(){return this.cachedArea||(this.cachedArea=I.getPolygonAreaSigned(this.nodes)),this.cachedArea}}var Rr=k(43304),je=k.n(Rr);function Y(o,e){this.x=o,this.y=e,this.min=function(t){o=Math.min(o,t.x),e=Math.min(e,t.y)},this.max=function(t){o=Math.max(o,t.x),e=Math.max(e,t.y)},this.midpoint=function(t){return new Y((o+t.x)*.5,(e+t.y)*.5)},this.clone=function(){return new Y(this.x,this.y)},this.normalize=function(){var t=this.length();this.x/=t,this.y/=t},this.normalized=function(){var t=new Y(this.x,this.y);return t.normalize(),t},this.negate=function(){this.x=-this.x,this.y=-this.y},this.sqrLength=function(){return this.x*this.x+this.y*this.y},this.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},this.scale=function(t){this.x*=t,this.y*=t},this.add=function(t){this.x+=t.x,this.y+=t.y},this.sub=function(t){this.x-=t.x,this.y-=t.y},this.diff=function(t){return new Y(this.x-t.x,this.y-t.y)},this.distance=function(t){var n=this.x-t.x,r=this.y-t.y;return Math.sqrt(n*n+r*r)},this.dot=function(t){return this.x*t.x+this.y*t.y},this.equals=function(t){return this.x==t.x&&this.y==t.y},this.orthogonal=function(){return new Y(this.y,-this.x)},this.distanceToLine=function(t,n){var r=n.diff(t).sqrLength(),s=((this.x-t.x)*(n.x-t.x)+(this.y-t.y)*(n.y-t.y))/r,i=n.diff(t);i.scale(s);var a=t.clone();return a.add(i),this.distance(a)}}var Dt=0,Ot=1,Pr=2,Ue=1e-5;function Br(o,e,t){var n=(e.x-o.x)*(t.y-o.y)-(e.y-o.y)*(t.x-o.x);return n>Ue?Ot:n<-Ue?Pr:Dt}function Ar(o){if(o.length<3)return o;for(var e=o[0],t=[],n=1;n<o.length;n++)(o[n].x<e.x||Math.abs(o[n].x-e.x)<Ue&&o[n].y<e.y)&&(e=o[n]);do{t.unshift(e.clone());for(var r=o[0],s=1;s<o.length;s++){var i=Br(e,r,o[s]);(r.equals(e)||i==Ot||i==Dt&&e.distance(o[s])>e.distance(r))&&(r=o[s])}e=r}while(!r.equals(t[t.length-1]));return t}function De(o,e,t,n){var r=e.x*n.y-e.y*n.x,s=t.x-o.x,i=t.y-o.y,a=(s*n.y-i*n.x)/r;return new Y(o.x+a*e.x,o.y+a*e.y)}function Lr(o){let e,t;const n=function(S,F,R,D,N,O,E,se){var Q=De(S,F,N,O),te=De(R,D,N,O),Re=De(E,se,S,F),Ge=De(E,se,R,D),et=Q.distance(te),ps=Q.distance(Re),en=et*ps;en<e&&(t=[Q,Re,Ge,te],e=en)};e=Number.MAX_VALUE,t=[];for(var r=[],s=0;s<o.length;s++)r.push(o[(s+1)%o.length].diff(o[s])),r[s].normalize();for(var i=new Y(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),a=new Y(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),l,c,d,h,s=0;s<o.length;s++){var f=o[s];f.x<i.x&&(i.x=f.x,l=s),f.x>a.x&&(a.x=f.x,c=s),f.y<i.y&&(i.y=f.y,h=s),f.y>a.y&&(a.y=f.y,d=s)}for(var p=new Y(0,-1),g=new Y(0,1),m=new Y(-1,0),x=new Y(1,0),s=0;s<o.length;s++){var y=[Math.acos(p.dot(r[l])),Math.acos(g.dot(r[c])),Math.acos(m.dot(r[d])),Math.acos(x.dot(r[h]))],M=y.indexOf(Math.min.apply(Math,y));switch(M){case 0:p=r[l].clone(),g=p.clone(),g.negate(),m=p.orthogonal(),x=m.clone(),x.negate(),l=(l+1)%o.length;break;case 1:g=r[c].clone(),p=g.clone(),p.negate(),m=p.orthogonal(),x=m.clone(),x.negate(),c=(c+1)%o.length;break;case 2:m=r[d].clone(),x=m.clone(),x.negate(),p=x.orthogonal(),g=p.clone(),g.negate(),d=(d+1)%o.length;break;case 3:x=r[h].clone(),m=x.clone(),m.negate(),p=x.orthogonal(),g=p.clone(),g.negate(),h=(h+1)%o.length;break}n(o[l],p,o[c],g,o[d],m,o[h],x)}return t}var Dr=k(43745),Ct=k.n(Dr),zt=k(26806);class Xe{constructor(e){e&&(this.vertices=e.vertices.map(t=>new u(t[0],t[1])),this.polygons=e.polygons.map(t=>{const n=t.map(r=>this.vertices[r]);return{vertices:n,edgeStart:n[n.length-1],edgeEnd:n[0]}}))}clone(){const e=new Xe;return e.vertices=this.vertices.map(t=>u.clone(t)),e.polygons=this.polygons.map(t=>{const n=t.vertices.map(r=>e.vertices[this.vertices.indexOf(r)]);return{vertices:n,edgeStart:n[n.length-1],edgeEnd:n[0]}}),e}}class Gt{constructor(){this.rings=[],this.cachedStraightSkeleton=null,this.cachedOMBB=null,this.cachedPoleOfInaccessibility=null}addRing(e){this.rings.push(e)}setOMBB(e){this.cachedOMBB=e}setPoleOfInaccessibility(e){this.cachedPoleOfInaccessibility=e}getFootprint({height:e,flip:t}){const n=[],r=[],s=[],i=t?-1:1,a=this.rings.filter(c=>c.type===j.Inner),l=this.rings.filter(c=>c.type===j.Outer);for(const c of l){const{vertices:d,holes:h}=this.getRingEarcutInput(c,a),f=je()(d,h);t||f.reverse();for(let p=0;p<f.length;p++)n.push(d[f[p]*2],e,d[f[p]*2+1]),r.push(d[f[p]*2],d[f[p]*2+1]),s.push(0,i,0)}return{positions:n,uvs:r,normals:s}}getRingEarcutInput(e,t){let n=[...e.getFlattenVertices()];const r=[];for(const s of t)r.push(n.length/2),n=n.concat(s.getFlattenVertices());return{vertices:n,holes:r}}getStraightSkeleton(){if(!this.cachedStraightSkeleton){const e=this.getStraightSkeletonInput();if(e.length===0)return null;let t=null;try{t=zt.SkeletonBuilder.buildFromPolygon(e)}catch(n){console.error(`Failed to build straight skeleton
`,n)}t?this.cachedStraightSkeleton=new Xe(t):console.error("Straight skeleton is null")}return this.cachedStraightSkeleton}getStraightSkeletonInput(){const e=this.rings.find(r=>r.type===j.Outer),t=this.rings.filter(r=>r.type===j.Inner);if(!e)return[];const n=[e.getGeoJSONVertices()];for(const r of t)n.push(r.getGeoJSONVertices());return n}getAABB(){const e=new me;for(const t of this.rings)e.includeAABB(t.getAABB());return e}getOMBBInput(){const e=[];for(const t of this.rings)t.type===j.Outer&&e.push(...t.nodes.map(n=>new Y(n.x,n.y)));return e}getOMBB(){if(!this.cachedOMBB){const e=this.getOMBBInput(),t=Ar(e),n=Lr(t);this.cachedOMBB=[new u(n[0].x,n[0].y),new u(n[1].x,n[1].y),new u(n[2].x,n[2].y),new u(n[3].x,n[3].y)]}return this.cachedOMBB}getPoleOfInaccessibility(){if(!this.cachedPoleOfInaccessibility){const e=this.rings.find(i=>i.type===j.Outer),t=this.rings.filter(i=>i.type===j.Inner);if(!e)return null;const n=e.getGeoJSONVertices(),r=t.map(i=>i.getGeoJSONVertices()),s=Ct()([n,...r],1);this.cachedPoleOfInaccessibility=new w(s[0],s[1],s.distance)}return this.cachedPoleOfInaccessibility}populateWithPoints(e,t){const n=this.getCoveredTiles(e,t),r=[];for(const s of n){const[i,a]=s.split(" ").map(d=>+d),l=new u((i+.75-Math.random()*.5)/e*t,(a+.75-Math.random()*.5)/e*t);let c=!0;for(const d of this.rings)d.type===j.Outer?d.isContainsPoints(l)||(c=!1):d.isContainsPoints(l)&&(c=!1);c&&r.push(l)}return r}getCoveredTiles(e,t){const n=new Set,r=[];for(const s of this.rings)if(s.type===j.Outer)r.push([s]);else{if(!r[r.length-1])return console.error("Invalid ring order, skipping covered tiles calculation"),n;r[r.length-1].push(s)}for(const s of r){const{vertices:i,holes:a}=this.getRingEarcutInput(s[0],s.slice(1)),l=je()(i,a);for(let c=0;c<l.length;c+=3){const d=[[i[l[c]*2],i[l[c]*2+1]],[i[l[c+1]*2],i[l[c+1]*2+1]],[i[l[c+2]*2],i[l[c+2]*2+1]]],h=I.getTilesUnderTriangle(d,1/t*e,1/t*e);for(const f of h)n.add(`${f.x} ${f.y}`)}}return n}getArea(){let e=0;for(const t of this.rings)e+=t.getArea();return e}}class $ extends bt{constructor(e,t){super(),e&&t?(this.isEmpty=!1,this.min=e,this.max=t):(this.min=new w,this.max=new w)}includePoint(e){if(this.isEmpty){this.min.set(e.x,e.y,e.z),this.max.set(e.x,e.y,e.z),this.isEmpty=!1;return}this.min.x=Math.min(this.min.x,e.x),this.min.y=Math.min(this.min.y,e.y),this.min.z=Math.min(this.min.z,e.z),this.max.x=Math.max(this.max.x,e.x),this.max.y=Math.max(this.max.y,e.y),this.max.z=Math.max(this.max.z,e.z)}includeAABB(e){if(this.isEmpty){this.min.set(e.min.x,e.min.y,e.min.z),this.max.set(e.max.x,e.max.y,e.max.z),this.isEmpty=!1;return}this.min.x=Math.min(this.min.x,e.min.x),this.min.y=Math.min(this.min.y,e.min.y),this.min.z=Math.min(this.min.z,e.min.z),this.max.x=Math.max(this.max.x,e.max.x),this.max.y=Math.max(this.max.y,e.max.y),this.max.z=Math.max(this.max.z,e.max.z)}includesPoint(e){return this.min.x<=e.x&&e.x<=this.max.x&&this.min.y<=e.y&&e.y<=this.max.y&&this.min.z<=e.z&&e.z<=this.max.z}intersectsAABB(e){return this.isEmpty||e.isEmpty?!1:!(e.max.x<=this.min.x||e.min.x>=this.max.x||e.max.y<=this.min.y||e.min.y>=this.max.y||e.max.z<=this.min.z||e.min.z>=this.max.z)}clone(){return new $(w.clone(this.min),w.clone(this.max))}move(e,t,n){const r=new w(e,t,n);return new $(w.add(this.min,r),w.add(this.max,r))}scaleScalar(e){return new $(w.multiplyScalar(this.min,e),w.multiplyScalar(this.max,e))}getCornerPoints(){return[this.min,new w(this.max.x,this.min.y,this.min.z),new w(this.min.x,this.max.y,this.min.z),new w(this.min.x,this.min.y,this.max.z),new w(this.max.x,this.max.y,this.min.z),new w(this.min.x,this.max.y,this.max.z),new w(this.max.x,this.min.y,this.max.z),this.max]}rotate2D(e){const t=this.getCornerPoints(),n=new $;for(const r of t){const s=w.rotateAroundAxis(r,new w(0,1,0),e);n.includePoint(s)}return n}rotateEuler(e,t,n){const r=this.getCornerPoints(),s=new $;for(const i of r){let a=w.rotateAroundAxis(i,new w(1,0,0),e);a=w.rotateAroundAxis(a,new w(0,1,0),t),a=w.rotateAroundAxis(a,new w(0,0,1),n),s.includePoint(a)}return s}scale(e,t,n){const r=new w(e,t,n);return new $(w.multiplyPerComponent(this.min,r),w.multiplyPerComponent(this.max,r))}toSpace(e){const t=w.applyMatrix4(this.min,e),n=w.applyMatrix4(this.max,e);return new $(t,n)}getCenter(){return new w((this.max.x+this.min.x)/2,(this.max.y+this.min.y)/2,(this.max.z+this.min.z)/2)}static fromFrustum(e){const t=new $;for(let n=0;n<4;n++)t.includePoint(e.vertices.near[n]),t.includePoint(e.vertices.far[n]);return t}}var Oe=(o=>(o[o.Along=0]="Along",o[o.Across=1]="Across",o))(Oe||{});class Or{static build({multipolygon:e,isOriented:t,stretch:n,orientation:r,uvScale:s}){const i=e.getFootprint({height:0,flip:!1});if(t){const a=e.getOMBB(),l=a[1];let c=u.sub(a[0],l),d=u.sub(a[2],l),h=u.getLength(c),f=u.getLength(d),p=!1;r===0?p=h>f:p=h<f,p&&([c,d]=[d,c],[h,f]=[f,h]);const g=-u.angleClockwise(new u(1,0),c),m=new u(1/h,1/f);for(let x=0;x<i.uvs.length;x+=2){const y=i.uvs[x],M=i.uvs[x+1],S=u.rotate(u.sub(new u(y,M),l),g),F=new u(S.x,S.y);n&&(F.x*=m.x,F.y*=m.y),i.uvs[x]=F.x,i.uvs[x+1]=-F.y}}for(let a=0;a<i.uvs.length;a++)i.uvs[a]/=s;return{position:i.positions,uv:i.uvs,normal:i.normals}}}var Te=(o=>(o[o.Both=0]="Both",o[o.Left=1]="Left",o[o.Right=2]="Right",o))(Te||{});class Nt{static build({vertices:e,vertexAdjacentToStart:t,vertexAdjacentToEnd:n,width:r,uvFollowRoad:s,uvScale:i=1,uvScaleY:a=1,side:l=0,uvMinX:c=0,uvMaxX:d=1}){const h=e[0].equals(e[e.length-1]),f=[...e];h&&f.pop();const p=this.getControlPoints(f,h,r,t,n),g=this.getBorderVertices(p,h),m=this.buildSegmentsFromControlPoints(p,h,a,c,d,l);return s||this.fillUVsFromPositions(m.uv,m.position,i),{position:m.position,uv:m.uv,border:g}}static getBorderVertices(e,t){const n=e.length-(t?0:1),r=[];for(let s=0;s<n;s++){const i=e[s],a=e[(s+1)%e.length];i[4]&&(i[2].equals(i[0])?r.unshift(i[4]):r.push(i[4])),r.push(i[0],a[2]),r.unshift(a[3],i[1])}return r.push(r[0]),r}static buildConnectionAttributesStart(e,t,n,r,s,i,a,l,c,d){if(t===0){const F=[i,r/l],R=[a,r/l],D=[s?a:i,n/l];c.push(e[0].x,0,e[0].y,e[1].x,0,e[1].y,e[4].x,0,e[4].y),d.push(...F,...R,...D);return}const h=(i+a)/2,f=u.multiplyScalar(u.add(e[0],e[1]),.5),p=s?u.multiplyScalar(u.add(e[2],e[4]),.5):u.multiplyScalar(u.add(e[1],e[4]),.5),g=[h,r/l],m=[h,(n+r)/2/l],x=[i,r/l],y=[a,r/l],M=[s?a:i,n/l];if(t===1===s){c.push(p.x,0,p.y,f.x,0,f.y,e[4].x,0,e[4].y);const F=s?e[1]:e[0],R=s?y:x;c.push(f.x,0,f.y,F.x,0,F.y,e[4].x,0,e[4].y),d.push(...m,...g,...M,...g,...R,...M)}else{const F=s?e[0]:e[1],R=s?x:y;c.push(p.x,0,p.y,F.x,0,F.y,f.x,0,f.y),d.push(...m,...R,...g)}}static buildConnectionAttributesEnd(e,t,n,r,s,i,a,l,c,d){if(t===0){const F=[i,n/l],R=[a,n/l],D=[s?a:i,r/l];c.push(e[2].x,0,e[2].y,e[3].x,0,e[3].y,e[4].x,0,e[4].y),d.push(...F,...R,...D);return}const h=(i+a)/2,f=u.multiplyScalar(u.add(e[2],e[3]),.5),p=s?u.multiplyScalar(u.add(e[2],e[4]),.5):u.multiplyScalar(u.add(e[1],e[4]),.5),g=[h,n/l],m=[h,(n+r)/2/l],x=[i,n/l],y=[a,n/l],M=[s?a:i,r/l];if(t===1===s){c.push(f.x,0,f.y,p.x,0,p.y,e[4].x,0,e[4].y);const F=s?e[3]:e[2],R=s?y:x;c.push(f.x,0,f.y,e[4].x,0,e[4].y,F.x,0,F.y),d.push(...g,...m,...M,...g,...M,...R)}else{const F=s?e[2]:e[3],R=s?x:y;c.push(f.x,0,f.y,F.x,0,F.y,p.x,0,p.y),d.push(...g,...R,...m)}}static buildConnection(e,t,n,r,s,i,a,l,c){if(!e[4])return n;const d=e[2].equals(e[0]),h=u.getLength(u.sub(e[4],d?e[1]:e[0])),f=n,p=f+h;return c==="start"?this.buildConnectionAttributesStart(e,t,f,p,d,r,s,i,a,l):this.buildConnectionAttributesEnd(e,t,f,p,d,r,s,i,a,l),p}static buildSegment(e,t,n,r,s,i,a,l,c){const d=e[0],h=e[1],f=t[2],p=t[3],g=u.getLength(u.sub(d,f)),m=r,x=r+g;if(n===0)l.push(d.x,0,d.y,h.x,0,h.y,f.x,0,f.y),l.push(h.x,0,h.y,p.x,0,p.y,f.x,0,f.y),c.push(s,m/a,i,m/a,s,x/a),c.push(i,m/a,i,x/a,s,x/a);else{const y=u.multiplyScalar(u.add(f,p),.5),M=u.multiplyScalar(u.add(d,h),.5),S=(s+i)/2;n===1?(l.push(h.x,0,h.y,M.x,0,M.y,p.x,0,p.y),l.push(M.x,0,M.y,y.x,0,y.y,p.x,0,p.y),c.push(i,m/a,S,m/a,i,x/a),c.push(S,m/a,S,x/a,i,x/a)):(l.push(d.x,0,d.y,M.x,0,M.y,f.x,0,f.y),l.push(M.x,0,M.y,y.x,0,y.y,f.x,0,f.y),c.push(s,m/a,S,m/a,s,x/a),c.push(S,m/a,S,x/a,s,x/a))}return x}static buildSegmentsFromControlPoints(e,t,n,r,s,i){const a=[],l=[],c=e.length-(t?0:1);let d=0;for(let h=0;h<c;h++){const f=e[h],p=e[(h+1)%e.length];d=this.buildConnection(f,i,d,r,s,n,a,l,"start"),d=this.buildSegment(f,p,i,d,r,s,n,a,l),d=this.buildConnection(p,i,d,r,s,n,a,l,"end")}return{position:a,uv:l}}static fillUVsFromPositions(e,t,n){for(let r=0,s=0;r<e.length;r+=2,s+=3){const i=t[s],a=t[s+2];e[r]=i/n,e[r+1]=a/n}}static getControlPoints(e,t,n,r,s){const i=[];for(let a=0;a<e.length;a++){const l=e[a];let c=e[a-1],d=e[a+1];t?(c||(c=e[e.length-1]),d||(d=e[0])):(!c&&r&&(c=r),!d&&s&&(d=s));let h,f;c&&(h=u.sub(l,c)),d&&(f=u.sub(d,l)),h||(h=u.clone(f)),f||(f=u.clone(h));const p=u.normalize(h),g=u.normalize(f),m=u.rotateLeft(p),x=u.rotateLeft(g),y=Math.atan2(g.y,g.x)-Math.atan2(p.y,p.x),M=y<0?y+Math.PI*2:y,S=u.normalize(u.add(m,x)),F=n/(2*Math.cos(y/2)),R=!c&&!d?n/2:Math.min(Math.abs(F),n*5),D=M>=Math.PI,N=u.add(l,u.multiplyScalar(S,R)),O=u.add(l,u.multiplyScalar(S,-R)),E=this.reflectPoint(D?O:N,l,u.add(l,p)),se=this.reflectPoint(D?O:N,l,u.add(l,g)),Q=D?se:N,te=D?O:se,Re=D?E:N,Ge=D?O:E,et=D?N:O;!c||!d?i.push([Q,te,Re,Ge]):i.push([Q,te,Re,Ge,et])}return i}static calculateSlope(e,t){return(t.y-e.y)/(t.x-e.x)}static calculateYIntercept(e,t){return(t.x*e.y-e.x*t.y)/(t.x-e.x)}static reflectPoint(e,t,n){if(n.x-t.x===0)return new u(2*n.x-e.x,e.y);const r=this.calculateSlope(t,n),s=this.calculateYIntercept(t,n),i=(e.x+(e.y-s)*r)/(1+r*r);return new u(2*i-e.x,2*i*r-e.y+2*s)}}class Ht{static project({triangle:e,attributes:t,tileSize:n,segmentCount:r,height:s=0}){const i=this.normalizeTriangle(e,n),a=this.getIntersectingGroundTrianglesForTriangle(i,r),l=i.flat(),c=[],d=new Map;for(const h of Object.keys(t))d.set(h,[]);if(I.isTriangleDegenerate(l))return this.mergePositionsAndAttributes(c,d);for(let h=0;h<a.length;h++){const f=I.findIntersectionTriangleTriangle(a[h],i);if(f.length===0)continue;const p=this.triangulateConvex(f),g=new Float32Array(p.length*3),m=new Map;for(const x of Object.keys(t))m.set(x,new Float32Array(p.length*2));for(let x=0;x<p.length;x++){const y=p[x],M=f[y][0],S=f[y][1];g[x*3]=M*n,g[x*3+1]=s,g[x*3+2]=S*n;for(const[F,R]of Object.entries(t)){const D=I.getBarycentricCoordinatesOfPoint(new u(M,S),l),N=m.get(F);N[x*2]=R[0][0]*D.x+R[1][0]*D.y+R[2][0]*D.z,N[x*2+1]=R[0][1]*D.x+R[1][1]*D.y+R[2][1]*D.z}}c.push(g);for(const[x,y]of m.entries())d.get(x).push(y)}return this.mergePositionsAndAttributes(c,d)}static projectLineSegment({lineStart:e,lineEnd:t,tileSize:n,segmentCount:r}){const s=u.multiplyScalar(e,1/n),i=u.multiplyScalar(t,1/n),a=this.getIntersectingGroundTrianglesForLine(s,i,r);if(a.length===0)return{vertices:[],startProgress:0};const l=new Set;s.x>=0&&s.x<=1&&s.y>=0&&s.y<=1&&l.add(0),i.x>=0&&i.x<=1&&i.y>=0&&i.y<=1&&l.add(1);for(const h of a){const f=I.getIntersectionsLineTriangle(u.toArray(s),u.toArray(i),h);for(const p of f){const g=I.getPointProgressAlongLineSegment(s,i,new u(p[0],p[1]));l.add(g)}}const c=Array.from(l).sort((h,f)=>h-f),d=u.sub(t,e);return{vertices:c.map(h=>u.add(e,u.multiplyScalar(d,h))),startProgress:c[0]}}static normalizeTriangle(e,t){return e.map(n=>[n[0]/t,n[1]/t])}static getIntersectingGroundTrianglesForTriangle(e,t){const n=[],r=I.getTilesUnderTriangle(e,t,t,0,0,t-1,t-1);for(const s of r)n.push(this.getTriangle(s.x,s.y,0,t),this.getTriangle(s.x,s.y,1,t));return n}static getIntersectingGroundTrianglesForLine(e,t,n){const r=[],s=I.getTilesIntersectingLine(u.multiplyScalar(e,n),u.multiplyScalar(t,n));for(const i of s)i.x<0||i.y<0||i.x>=n||i.y>=n||r.push(this.getTriangle(i.x,i.y,0,n),this.getTriangle(i.x,i.y,1,n));return r}static mergePositionsAndAttributes(e,t){const n={};for(const[r,s]of t.entries())n[r]=V.mergeTypedArrays(Float32Array,s);return{position:V.mergeTypedArrays(Float32Array,e),attributes:n}}static triangulateConvex(e){const t=[];if(e.length<3)return t;for(let n=2;n<e.length;n++)t.push(0,n,n-1);return t}static getTriangle(e,t,n,r){const s=1/r,i=e/r,a=t/r,l=(e+t)%2===1,c=[i,a,i+s,a,i+s,a+s,i,a+s];let d;l?n===0?d=[1,0,3]:d=[1,3,2]:n===0?d=[0,2,1]:d=[0,3,2];const h=[];for(let f=0;f<3;f++){const p=d[f],g=c[p*2],m=c[p*2+1];h.push([g,m])}return h}}function Cr(o){return[o>>16,o>>8&255,o&255]}function le(o,e){const t=u.sub(e[1],e[0]),n=u.sub(o,e[0]),r=t.x*n.y-t.y*n.x,s=Math.hypot(t.x,t.y);return r/s}function zr({position:o,uv:e,height:t=0}){const n=Math.round(J.TileSize/J.TerrainRingSize*J.TerrainRingSegmentCount)*2,r=J.TileSize,s=[],i=[];for(let a=0,l=0;a<o.length;a+=9,l+=6){const c=[[o[a],o[a+2]],[o[a+3],o[a+5]],[o[a+6],o[a+8]]],d=[[e[l],e[l+1]],[e[l+2],e[l+3]],[e[l+4],e[l+5]]],h=Ht.project({triangle:c,attributes:{uv:d},tileSize:r,segmentCount:n});if(h.position.length>0){const f=Array.from(h.position),p=Array.from(h.attributes.uv);for(let g=1;g<f.length;g+=3)f[g]=t;s.push(...f),i.push(...p)}}return{position:s,uv:i}}function Wt(o){const e=Math.round(J.TileSize/J.TerrainRingSize*J.TerrainRingSegmentCount)*2,t=[];let n=0;for(let r=0;r<o.length-1;r++){const s=o[r],i=o[r+1],a=u.distance(s,i),l=Ht.projectLineSegment({lineStart:s,lineEnd:i,tileSize:J.TileSize,segmentCount:e});if(l.vertices.length===0){n+=a;continue}if(t.length>0){const c=t[t.length-1].vertices;if(c[c.length-1].equals(l.vertices[0])){for(let h=1;h<l.vertices.length;h++)c.push(l.vertices[h]);n+=a;continue}}t.push({vertices:l.vertices,startProgress:n+l.startProgress*a}),n+=a}return t}function Gr(o){const e=I.toDeg(I.normalizeAngle(I.toRad(o)));return e>=45&&e<135?90:e>=135&&e<225?180:e>=225&&e<315?270:0}function Vt(o,e,t){let n=o[0],r=u.sub(o[3],n),s=u.sub(o[1],n);if(typeof t=="number"){const i=u.angleClockwise(new u(1,0),r),a=Gr(t-I.toDeg(i));if(a!==0){let l=a;l<0&&(l+=360);const c=Math.floor(l/90),d=(c+3)%4,h=(c+1)%4;n=o[c],r=u.sub(o[d],n),s=u.sub(o[h],n)}}else if(typeof e=="string"){const i=u.getLength(r),a=u.getLength(s);(i>a&&e==="along"||i<a&&e==="across")&&(n=o[1],r=u.sub(o[0],n),s=u.sub(o[2],n))}return{origin:n,rotVector0:r,rotVector1:s}}class Et{static build({vertices:e,minHeight:t,height:n,uvWidth:r,uvHeight:s,uvHorizontalOffset:i=0}){const a=[],l=[],c=[];let d=i;const h=t+n;for(let f=0;f<e.length-1;f++){const p=e[f],g=e[f+1],m=u.distance(p,g);a.push(p.x,t,p.y,g.x,t,g.y,p.x,h,p.y,g.x,t,g.y,g.x,h,g.y,p.x,h,p.y),l.push(d/r,0,(d+m)/r,0,d/r,s,(d+m)/r,0,(d+m)/r,s,d/r,s);const x=I.calculateNormal(new w(g.x,0,g.y),new w(p.x,1,p.y),new w(p.x,0,p.y));for(let y=0;y<6;y++)c.push(x.x,x.y,x.z);d+=m}return{position:a,uv:l,normal:c}}}const qt=2e4;function ce(o,e){let t=0,n=e.length;if(n<=qt)o.push.apply(o,e);else for(;n>0;){const r=Math.min(qt,n),s=e.slice(t,t+r);o.push.apply(o,s),n-=r,t+=r}return o}class Ie{constructor(e){this.arrays={position:[],uv:[],normal:[],textureId:[]},this.terrainMaskPositions=[],this.boundingBox=new $,this.multipolygon=new Gt,this.zIndex=0,e&&(this.multipolygon=e)}addRing(e,t){const n=new Lt(e,t);this.multipolygon.addRing(n)}setZIndex(e){this.zIndex=e}addPolygon({textureId:e,height:t,uvScale:n=1,isOriented:r=!1,stretch:s=!1,orientation:i=Oe.Along,addUsageMask:a}){const l=Or.build({multipolygon:this.multipolygon,isOriented:r,orientation:i,stretch:s,uvScale:n});this.projectAndAddGeometry({position:l.position,uv:l.uv,textureId:e,height:t}),a&&this.addMaskGeometry(l.position)}addPath({vertexAdjacentToStart:e=null,vertexAdjacentToEnd:t=null,width:n,uvFollowRoad:r,uvScale:s=1,uvScaleY:i=1,side:a=Te.Both,uvMinX:l=0,uvMaxX:c=1,height:d=0,textureId:h}){const f=Nt.build({vertices:this.multipolygon.rings[0].nodes,vertexAdjacentToStart:e,vertexAdjacentToEnd:t,width:n,uvFollowRoad:r,uvScale:s,uvScaleY:i,side:a,uvMinX:l,uvMaxX:c});this.projectAndAddGeometry({position:f.position,uv:f.uv,textureId:h,height:d}),this.addMaskGeometry(f.position)}addFence({minHeight:e,height:t,width:n,textureId:r}){const s=this.multipolygon.rings[0],i=Wt(s.nodes);for(const a of i){const l=Et.build({vertices:a.vertices,minHeight:e,height:t,uvWidth:n,uvHeight:1,uvHorizontalOffset:a.startProgress});this.addGeometry({position:l.position,normal:l.normal,uv:l.uv,textureId:r})}}addExtrudedPath({width:e,height:t,textureId:n,textureScaleX:r,textureScaleY:s}){const i=Nt.build({vertices:this.multipolygon.rings[0].nodes,width:e,uvFollowRoad:!0,uvScaleY:s,uvMinX:0,uvMaxX:e/r});this.projectAndAddGeometry({position:i.position,uv:i.uv,textureId:n,height:t});const a=Wt(i.border);for(const l of a){const c=Et.build({vertices:l.vertices,minHeight:0,height:t,uvWidth:r,uvHeight:t/s,uvHorizontalOffset:l.startProgress});this.addGeometry({position:c.position,normal:c.normal,uv:c.uv,textureId:n})}}projectAndAddGeometry({position:e,uv:t,textureId:n,height:r=0}){const s=zr({position:e,uv:t,height:r});ce(this.arrays.position,s.position),ce(this.arrays.uv,s.uv),this.addVerticesToBoundingBox(s.position);const i=s.position.length/3;for(let a=0;a<i;a++)this.arrays.normal.push(0,1,0),this.arrays.textureId.push(n)}addGeometry({position:e,normal:t,uv:n,textureId:r}){ce(this.arrays.position,e),ce(this.arrays.normal,t),ce(this.arrays.uv,n),this.addVerticesToBoundingBox(e);const s=e.length/3;for(let i=0;i<s;i++)this.arrays.textureId.push(r)}addMaskGeometry(e){for(let t=0;t<e.length;t+=3)this.terrainMaskPositions.push(e[t],e[t+2])}addVerticesToBoundingBox(e){const t=new w;for(let n=0;n<e.length;n+=3)t.set(e[n],e[n+1],e[n+2]),this.boundingBox.includePoint(t)}getGeometry(){return{type:"projected",zIndex:this.zIndex,boundingBox:this.boundingBox,positionBuffer:new Float32Array(this.arrays.position),normalBuffer:new Float32Array(this.arrays.normal),uvBuffer:new Float32Array(this.arrays.uv),textureIdBuffer:new Uint8Array(this.arrays.textureId)}}getTerrainMaskGeometry(){return{type:"mask",positionBuffer:new Float32Array(this.terrainMaskPositions)}}}const L={Water:0,Pavement:1,Asphalt:2,Cobblestone:3,FootballPitch:4,BasketballPitch:5,TennisCourt:6,ManicuredGrass:7,Cycleway:8,Railway:9,Rock:10,Sand:11,Hedge:12,WoodFence:13,ConcreteFence:14,AsphaltRoad:15,AsphaltUnmarkedRoad:16,ConcreteRoad:17,ConcreteUnmarkedRoad:18,ConcreteIntersection:19,WoodRoad:20,Helipad:21,Garden:22,Soil:23,Grass:24,ForestFloor:25,ChainLinkFence:26,MetalFence:27,StoneWall:28,ConcreteWall:29,Farmland0:30,Farmland1:31,Farmland2:32,Gravel:33,DirtRoad:34,SandRoad:35,RailwayTop:36,Rail:37,GenericPitch:38},G={RoofGeneric1:0,RoofGeneric2:1,RoofGeneric3:2,RoofGeneric4:3,RoofTiles:4,RoofMetal:5,RoofConcrete:6,RoofThatch:7,RoofEternit:8,RoofGrass:9,RoofGlass:10,RoofTar:11,FacadeGlass:12,FacadeBrickWall:13,FacadeBrickWindow:14,FacadePlasterWall:15,FacadePlasterWindow:16,FacadeWoodWall:17,FacadeWoodWindow:18,FacadeBlockWall:19,FacadeBlockWindow:20};class he{constructor(e){this.mercatorScale=1,this.graph=null,this.graphRoad=null,this.graphGroup=-1,this.osmReference=e.osmReference,this.descriptor=e.descriptor,this.vertices=e.nodes.map(t=>new u(t.x,t.y))}getRequestedHeightPositions(){return null}setMercatorScale(e){this.mercatorScale=e}getFeatures(){switch(this.descriptor.type){case"path":return this.handlePath();case"fence":return[this.handleFence()];case"wall":return[this.handleWall()];case"waterway":return[this.handleWaterway()]}return[]}setRoadGraph(e){if(this.descriptor.type==="path"){let t=-1;switch(this.descriptor.pathType){case"roadway":t=0;break;case"footway":t=1;break;case"cycleway":t=2;break;case"railway":t=3;break;case"tramway":t=4;break}t!==-1&&(this.graph=e,this.graphGroup=t,this.graphRoad=e.addRoad(this.vertices,this.descriptor.width*this.mercatorScale,t))}}getGraphRoad(){return this.graphRoad}handlePath(){const e=[],t=he.getRoadSideFromDescriptor(this.descriptor.side),n=he.getPathParams(this.descriptor.pathType,this.descriptor.pathMaterial,this.descriptor.isRoadwayMarked,this.descriptor.lanesForward,this.descriptor.lanesBackward,this.descriptor.width,this.mercatorScale),{vertices:r,vertexAdjacentToStart:s,vertexAdjacentToEnd:i}=this.getPathBuilderVertices();if(r.length<2)return e;for(const a of n){const l=new Ie;l.setZIndex(a.zIndex),l.addRing(j.Outer,r),l.addPath({width:this.descriptor.width*this.mercatorScale*a.widthScale,uvMinX:a.uvMinX,uvMaxX:a.uvMaxX,textureId:a.textureId,uvFollowRoad:a.uvFollowRoad,uvScale:a.uvScale,uvScaleY:a.uvScaleY,side:t,vertexAdjacentToStart:s,vertexAdjacentToEnd:i}),e.push(l.getGeometry()),a.needsUsageMask&&e.push(l.getTerrainMaskGeometry())}return e}getPathBuilderVertices(){const e=[...this.vertices],t=e[0],n=e[e.length-1];let r=null,s=null;if(!t.equals(n)&&this.graphRoad){const i=this.graphRoad.start.getIntersection(),a=this.graphRoad.end.getIntersection();i&&e.length>1&&(r=this.processPathEnd(e,i,"first")),a&&e.length>1&&(s=this.processPathEnd(e,a,"last"))}return{vertices:e,vertexAdjacentToStart:r,vertexAdjacentToEnd:s}}processPathEnd(e,t,n){let r=null;if(t.directions.length===2)for(const{road:s,vertex:i}of t.directions){const a=n==="first"?1:e.length-2;s!==this.graphRoad&&!i.vector.equals(e[a])&&(r=i.vector)}else if(t.directions.length>2&&!t.userData.skip){const s=t.directions.find(i=>i.road===this.graphRoad);if(s&&s.trimmedEnd&&e.length>1){const i=n==="first"?1:e.length-2;if(s.trimmedEnd.equals(e[i]))n==="first"?(r=e[0],e.shift()):(r=e[e.length-1],e.pop());else{const a=n==="first"?0:e.length-1;e[a].set(s.trimmedEnd.x,s.trimmedEnd.y)}}}return r}handleFence(){const e=new Ie;e.addRing(j.Outer,this.vertices);const{width:t,textureId:n}=he.getFenceParams(this.descriptor.fenceMaterial,this.descriptor.height);return e.addFence({minHeight:(this.descriptor.minHeight??0)*this.mercatorScale,height:this.descriptor.height*this.mercatorScale,width:t,textureId:n}),{...e.getGeometry(),type:"hugging"}}handleWall(){const e=new Ie;e.addRing(j.Outer,this.vertices);const t=he.getWallParams(this.descriptor.wallType);return e.addExtrudedPath({width:.8*this.mercatorScale,height:this.descriptor.height*this.mercatorScale,textureId:t.textureId,textureScaleX:t.uvScaleX,textureScaleY:t.uvScaleY}),{...e.getGeometry(),type:"hugging"}}handleWaterway(){const e=new Ie;return e.setZIndex(z.Waterway),e.addRing(j.Outer,this.vertices),e.addPath({width:this.descriptor.width*this.mercatorScale,uvFollowRoad:!1,textureId:L.Water}),e.getGeometry()}getIntersectionMaterial(){return this.descriptor.pathMaterial==="concrete"?"concrete":this.descriptor.pathMaterial==="asphalt"?"asphalt":this.descriptor.pathMaterial==="cobblestone"?"cobblestone":null}static getPathParams(e,t,n,r,s,i,a){const l=[{textureId:0,widthScale:1,uvScale:1,uvScaleY:1,uvMinX:0,uvMaxX:1,zIndex:0,uvFollowRoad:!1,needsUsageMask:!1}];switch(e){case"footway":{switch(t){case"wood":{l[0].textureId=L.WoodRoad,l[0].zIndex=z.WoodFootway,l[0].uvFollowRoad=!0,l[0].uvScaleY=4,l[0].uvMaxX=i/4;break}case"asphalt":{l[0].textureId=L.Asphalt,l[0].zIndex=z.AsphaltFootway,l[0].uvScale=20;break}default:l[0].textureId=L.Pavement,l[0].zIndex=z.Footway,l[0].uvScale=10}break}case"roadway":{const c=Tr(r,s);switch(l[0].uvMinX=c.minX,l[0].uvMaxX=c.maxX,l[0].uvFollowRoad=!0,t){case"asphalt":{l[0].textureId=n?L.AsphaltRoad:L.AsphaltUnmarkedRoad,l[0].zIndex=z.AsphaltRoadway,l[0].uvScaleY=12,l[0].needsUsageMask=!0;break}case"concrete":{l[0].textureId=n?L.ConcreteRoad:L.ConcreteUnmarkedRoad,l[0].zIndex=z.ConcreteRoadway,l[0].uvScaleY=12,l[0].needsUsageMask=!0;break}case"wood":{l[0].textureId=L.WoodRoad,l[0].zIndex=z.WoodRoadway,l[0].uvScaleY=4,l[0].uvMinX=0,l[0].uvMaxX=i*a/4,l[0].needsUsageMask=!0;break}case"cobblestone":{l[0].textureId=L.Cobblestone,l[0].zIndex=z.CobblestoneRoadway,l[0].uvMinX=0,l[0].uvMaxX=i*a/6,l[0].uvScaleY=6,l[0].needsUsageMask=!0;break}case"dirt":{l[0].uvFollowRoad=!0,l[0].textureId=L.DirtRoad,l[0].zIndex=z.DirtRoadway,l[0].widthScale=1.7,l[0].uvMinX=0,l[0].uvMaxX=1,l[0].uvScaleY=i*a;break}case"sand":{l[0].uvFollowRoad=!0,l[0].textureId=L.SandRoad,l[0].zIndex=z.SandRoadway,l[0].widthScale=1.7,l[0].uvMinX=0,l[0].uvMaxX=1,l[0].uvScaleY=i*a;break}}break}case"cycleway":{l[0].textureId=L.Cycleway,l[0].zIndex=z.Cycleway,l[0].uvFollowRoad=!1,l[0].uvScale=8;break}case"tramway":{l[0].textureId=L.Rail,l[0].zIndex=z.Rail,l[0].widthScale=2,l[0].uvFollowRoad=!0,l[0].uvMinX=0,l[0].uvMaxX=1,l[0].uvScaleY=i*a*4;break}case"railway":{l[0].textureId=L.Railway,l[0].zIndex=z.Railway,l[0].widthScale=2,l[0].uvFollowRoad=!0,l[0].uvMinX=0,l[0].uvMaxX=1,l[0].uvScaleY=i*a*4,l.push({textureId:L.RailwayTop,zIndex:z.RailwayOverlay,widthScale:2,uvFollowRoad:!0,uvMinX:0,uvMaxX:1,uvScaleY:i*a*4,uvScale:1,needsUsageMask:!1}),l.push({textureId:L.Rail,zIndex:z.Rail,widthScale:2,uvFollowRoad:!0,uvMinX:0,uvMaxX:1,uvScaleY:i*a*4,uvScale:1,needsUsageMask:!1});break}case"runway":{l[0].uvFollowRoad=!1,l[0].textureId=L.Asphalt,l[0].zIndex=z.Runway,l[0].uvScale=10;break}}return l}static getRoadSideFromDescriptor(e){return e==="left"?Te.Left:e==="right"?Te.Right:Te.Both}static getFenceParams(e,t){const r={wood:{textureId:L.WoodFence,widthRatio:1},concrete:{textureId:L.ConcreteFence,widthRatio:2},chainLink:{textureId:L.ChainLinkFence,widthRatio:1},metal:{textureId:L.MetalFence,widthRatio:1.64}}[e];return{textureId:r.textureId,width:t*r.widthRatio}}static getWallParams(e){const n={stone:{textureId:L.StoneWall,scaleX:4,scaleY:4},concrete:{textureId:L.ConcreteWall,scaleX:4.5,scaleY:3},hedge:{textureId:L.Hedge,scaleX:3,scaleY:3}}[e];return{textureId:n.textureId,uvScaleX:n.scaleX,uvScaleY:n.scaleY}}}class Ye{build(e){const{multipolygon:t,minHeight:n,flip:r}=e,s=t.getFootprint({height:n,flip:r}),i=t.getOMBB(),a=i[1],l=u.sub(i[0],a),c=u.sub(i[2],a),d=-u.angleClockwise(new u(1,0),l),h=e.isStretched?new u(u.getLength(l),u.getLength(c)):new u(e.scaleX,e.scaleY);for(let f=0;f<s.uvs.length;f+=2){const p=s.uvs[f],g=s.uvs[f+1],m=u.rotate(u.sub(new u(p,g),a),d);s.uvs[f]=m.x/h.x,s.uvs[f+1]=m.y/h.y}return{position:s.positions,normal:s.normals,uv:s.uvs,addSkirt:!1}}}class Nr{getRoofHeightFromAngle(e,t){return(e.max.y-e.min.y)*Math.tan(I.toRad(t))}getRotation(e){if(e.direction!==null)return-I.toRad(e.direction)-Math.PI/2;const t=e.multipolygon.getOMBB(),n=Vt(t,e.orientation??"along",null);return-u.normalize(n.rotVector0).getAngle()-Math.PI/2}getRotatedMultipolygonAABB(e,t){const n=new me;for(const r of e.rings)for(const s of r.nodes)n.includePoint(u.rotate(s,t));return n}build(e){const{multipolygon:t}=e,n=[],r=this.getRotation(e),s=this.getRotatedMultipolygonAABB(t,r);let i=null,a=e.height,l=e.minHeight;e.angle!==null&&e.angle!==void 0&&(a=this.getRoofHeightFromAngle(s,e.angle),l=e.buildingHeight-a,i=e.buildingHeight-a);const c=t.getFootprint({height:0,flip:!1});for(let y=0;y<c.positions.length;y+=3){const M=c.positions[y],S=c.positions[y+2],R=(u.rotate(new u(M,S),r).y-s.min.y)/(s.max.y-s.min.y);c.positions[y+1]=l+R*a}const d=s.max.y-s.min.y,h=1/e.scaleX,f=1/Math.sin(Math.atan(d/a))/e.scaleY;for(let y=0;y<c.uvs.length;y+=2){const M=c.uvs[y],S=c.uvs[y+1],F=u.rotate(new u(M,S),r);c.uvs[y]=(F.x-s.min.x)*h,c.uvs[y+1]=(F.y-s.min.y)*f}for(const y of t.rings){const M={points:[],hasWindows:!0};n.push(M);for(const S of y.nodes){const R=(u.rotate(S,r).y-s.min.y)/(s.max.y-s.min.y);M.points.push({position:S,height:l+R*a})}}const p=new w(c.positions[0],c.positions[1],c.positions[2]),g=new w(c.positions[3],c.positions[4],c.positions[5]),m=new w(c.positions[6],c.positions[7],c.positions[8]),x=I.calculateNormal(p,g,m);for(let y=0;y<c.normals.length;y+=3)c.normals[y]=x.x,c.normals[y+1]=x.y,c.normals[y+2]=x.z;return{addSkirt:!0,skirt:n,facadeHeightOverride:i,position:c.positions,normal:c.normals,uv:c.uvs}}}function _t(o,e,t){if(!o||o.length<3)throw new Error("splitPolygon: input polygon must have at least 3 vertices");const n=[];let r=o[o.length-1];for(let a=0;a<o.length;a++){const l=o[a],c=[l[0]-r[0],l[1]-r[1]],d=t[0]*c[1]-t[1]*c[0];if(d!=0){let h=t[0]*(e[1]-r[1])-t[1]*(e[0]-r[0]);const f=h/d;if(f>=0&&f<=1){const p=[r[0]+f*c[0],r[1]+f*c[1]];h=c[0]*(e[1]-r[1])-c[1]*(e[0]-r[0]);const g=h/d;n.push({is:(a+o.length-1)%o.length,ie:a,p,t:g})}}r=l}if(n.sort(function(a,l){return a.t<l.t?-1:a.t>l.t?1:0}),n.length%2!==0)throw new Error("splitPolygon: unknown error");const s=[[]];let i=s[0];for(let a=0;a<o.length;a++){i.push(o[a]);let l=null;for(let c=0;c<n.length;c++)if(n[c].is==a){l=c;break}l!==null&&(i.push(n[l].p),l%2==0?n[l+1].crossback=i:n[l-1].crossback=i,n[l].crossback?i=n[l].crossback:(i=[],s.push(i)),i.push(n[l].p))}return s}function Hr(o,e=!1){const t=[];for(let n=0;n<o.length;n+=9){const r=new w(o[n],o[n+1],o[n+2]),s=new w(o[n+3],o[n+4],o[n+5]),i=new w(o[n+6],o[n+7],o[n+8]),a=e?I.calculateNormal(i,s,r):I.calculateNormal(r,s,i),l=w.toArray(a);for(let c=n;c<n+9;c++)t[c]=l[c%3]}return t}function jt(o){const e=[],t=[];for(let n=0;n<o.length-1;n++){const r=o[n],s=o[n+1],i=u.sub(s,r);t.push(u.rotateLeft(i))}for(let n=0;n<o.length;n++){const r=t[n-1],s=t[n];if(!r){e.push(u.normalize(s));continue}if(!s){e.push(u.normalize(r));continue}const i=u.normalize(u.add(r,s));e.push(i)}return e}function Ut(o,e){const t=[o.edgeStart,o.edgeEnd],n=u.normalize(u.rotateRight(u.sub(t[1],t[0]))),r=u.multiplyScalar(n,-e),s=[u.add(t[0],r),u.add(t[1],r)],i=[];for(const d of o.vertices)i.push([d.x,d.y]);const a=[],l=[];let c=null;try{c=_t(i,u.toArray(s[0]),u.toArray(u.sub(s[0],s[1])))}catch{}if(!c||c.length===1)for(const d of o.vertices)l.push(d.x,d.y);else c.length>1&&(l.push(...c[0].flat()),a.push(...c[1].flat()));return{verticesTop:a,verticesBottom:l}}class $e{build(e){this.calculateSplitsNormals();const{multipolygon:t,minHeight:n,height:r,scaleX:s,scaleY:i}=e,a=n+r,c=t.rings.find(m=>m.type===j.Outer).nodes.slice(0,-1),d=this.getCenter(c),h=this.splitPolygon(c),f=[],p=[],g=[];for(const m of h){const x=this.getRoofPartPoints(m,a,n,d);this.buildRoofPart(f,p,g,x,s,i)}return{position:f,normal:p,uv:g,addSkirt:!1,canExtendOutsideFootprint:!0}}getRoofPartPoints(e,t,n,r){const s=e[0].equals(e[e.length-1]),i=[];for(let a=0;a<e.length;a++){const l=e[a],c=[],d=t-n,h=u.distance(l,r);let f;if(!s&&a===0){const p=e[a+1],g=u.sub(l,p);f=u.angleClockwise(new u(1,0),g)}else if(!s&&a===e.length-1){const p=e[a-1],g=u.sub(p,l);f=u.angleClockwise(new u(1,0),g)}else f=u.angleClockwise(new u(0,1),u.sub(l,r));for(let p=0;p<this.splits.length;p++){const g=this.splits[p],m=u.lerp(r,l,g.y),x=I.lerp(n,t,g.x),y=new w(m.x,x,m.y),M=this.splitsNormals[p],S=w.rotateAroundAxis(new w(M.y/h,M.x/d,0),new w(0,1,0),-f-Math.PI/2);c.push({position:y,normal:w.normalize(S)})}i.push(c)}return i}buildRoofPart(e,t,n,r,s,i){let a=0;for(let l=0;l<r.length-1;l++){const c=r[l],d=r[l+1],h=[c[0].position.xz,d[0].position.xz],f=u.sub(h[1],h[0]),p=[h[0],u.add(h[0],u.rotateRight(f))];let g=0;for(let m=0;m<c.length-1;m++){const x=c[m],y=c[m+1],M=d[m],S=d[m+1],F=[x,y,M,y,S,M],R=[0,1,0,1,1,0];y.position.equals(S.position)&&(F.splice(3),R.splice(3));const D=w.distance(x.position,y.position);for(let N=0;N<F.length;N++){const{position:O,normal:E}=F[N],se=R[N];e.push(O.x,O.y,O.z),t.push(E.x,E.y,E.z);const Q=g+se*D,te=a+le(O.xz,p);n.push(te/s,Q/i)}g+=D}a+=u.getLength(f)}}getCenter(e){let t=I.getPolygonCentroid(e);if(I.isPointInsidePolygon(t,e))return t;const n=e.map(s=>[s.x,s.y]),r=Ct()([n],1);return new u(r[0],r[1])}getPolygonSplitFlags(e){const t=[];for(let n=0;n<e.length;n++){if(this.isEdgy){t.push(!0);continue}const r=e[n],s=e[n-1]??e[e.length-1],i=e[n+1]??e[0],a=u.normalize(u.sub(r,s)),l=u.normalize(u.sub(i,r)),c=u.dot(a,l);t.push(c<Math.cos(I.toRad(40)))}return t}splitPolygon(e){const t=this.getPolygonSplitFlags(e),n=t.findIndex(i=>i);if(n!==-1)for(let i=0;i<n;i++)e.push(e.shift()),t.push(t.shift());let r=[e[0]];const s=[];for(let i=1;i<e.length+1;i++){const a=e[i]??e[0],l=t[i]??t[0];r.push(a),(l||i===e.length)&&(s.push(r),r=[a])}return s}calculateSplitsNormals(){this.splitsNormals=jt(this.splits)}}class Wr extends $e{constructor(){super(...arguments),this.splits=[new u(0,1),new u(1,0)],this.isEdgy=!0}}class Je{build(e){const{multipolygon:t,flip:n}=e,r=t.getStraightSkeleton();if(!r)return null;const s=this.getSkeletonMaxHeight(r);let i=e.height,a=e.minHeight,l=null;e.angle!==null&&e.angle!==void 0&&(i=s*Math.tan(I.toRad(e.angle??45)),a=e.buildingHeight-i,l=e.buildingHeight-i);const{position:c,uv:d,skirt:h}=this.convertSkeletonToVertices({multipolygon:t,skeleton:r,minHeight:a,height:i,maxSkeletonHeight:s,flip:n,scaleX:e.scaleX,scaleY:e.scaleY}),f=this.calculateNormals(c,n);return{position:c,normal:f,uv:d,addSkirt:!!h,skirt:h,facadeHeightOverride:l}}getSkeletonMaxHeight(e){let t=0;for(const n of e.polygons){const r=[n.edgeStart,n.edgeEnd];for(const s of n.vertices){const i=this.getVertexHeightFromEdge(s,r,1,1);t=Math.max(t,i)}}return t}convertSkeletonToVertices({multipolygon:e,skeleton:t,minHeight:n,height:r,maxSkeletonHeight:s,flip:i,scaleX:a,scaleY:l}){let c=[],d=[];for(const h of t.polygons){const{position:f,uv:p}=this.convertSkeletonPolygonToVertices({polygon:h,minHeight:n,height:r,maxSkeletonHeight:s,scaleX:a,scaleY:l});i&&f.reverse(),c=c.concat(f),d=d.concat(p)}return{position:c,uv:d}}convertSkeletonPolygonToVertices({polygon:e,minHeight:t,height:n,maxSkeletonHeight:r,scaleX:s,scaleY:i}){const a=[];for(const l of e.vertices)a.push(l.x,l.y);return this.triangulatePolygon(a,t,n,r,[e.edgeStart,e.edgeEnd],s,i)}triangulatePolygon(e,t,n,r,s,i,a,l=c=>c){const c=[],d=[],h=je()(e).reverse();for(let f=0;f<h.length;f++){const p=h[f],g=e[p*2],m=e[p*2+1],x=new u(g,m),y=le(x,s),M=t+n*l(y/r);c.push(g,M,m);const S=[s[1],u.add(s[1],u.rotateRight(u.sub(s[0],s[1])))],F=le(x,S),R=Math.sin(Math.atan(r/n));d.push(F/i,y/R/a)}return{position:c,uv:d}}calculateNormals(e,t=!1){const n=[];for(let r=0;r<e.length;r+=9){const s=new w(e[r],e[r+1],e[r+2]),i=new w(e[r+3],e[r+4],e[r+5]),a=new w(e[r+6],e[r+7],e[r+8]),l=t?I.calculateNormal(a,i,s):I.calculateNormal(s,i,a),c=w.toArray(l);for(let d=r;d<r+9;d++)n[d]=c[d%3]}return n}getVertexHeightFromEdge(e,t,n,r){return le(e,t)/n*r}}class Xt extends Je{convertSkeletonToVertices({multipolygon:e,skeleton:t,minHeight:n,height:r,maxSkeletonHeight:s,flip:i,scaleX:a,scaleY:l}){t=t.clone();const c=[];for(let p=0;p<t.polygons.length;p++){const g=t.polygons[p];if(g.vertices.length===3){const m=t.polygons.find(y=>y.edgeEnd.equals(g.edgeStart)),x=t.polygons.find(y=>y.edgeStart.equals(g.edgeEnd));if(m.vertices.length>3&&x.vertices.length>3){const y=g.edgeStart,M=g.edgeEnd,S=g.vertices.find(O=>!O.equals(y)&&!O.equals(M)),F=m.vertices.find(O=>O.equals(S)),R=x.vertices.find(O=>O.equals(S));let D=null;for(const O of m.vertices)if(x.vertices.some(E=>E.equals(O)&&!(E.equals(y)||E.equals(M)||E.equals(S)))){D=O;break}let N=!1;if(D){const O=new u(S.x,S.y),E=new u(D.x,D.y),se=u.add(E,u.multiplyScalar(u.sub(O,E),1e3)),Q=I.getIntersectionLineLine([y.x,y.y],[M.x,M.y],[E.x,E.y],[se.x,se.y]);if(Q){const te=new u(Q[0],Q[1]);c.push({begin:y,end:M,center:te,prevPolygon:m}),F.x=R.x=te.x,F.y=R.y=te.y,N=!0}}N&&(g.vertices.length=0)}}}s=this.getSkeletonMaxHeight(t);const d=this.buildSkirtFromSegmentsParams(c,n,r,s),{position:h,uv:f}=super.convertSkeletonToVertices({multipolygon:e,skeleton:t,minHeight:n,height:r,maxSkeletonHeight:s,flip:i,scaleX:a,scaleY:l});return{position:h,uv:f,skirt:d}}buildSkirtFromSegmentsParams(e,t,n,r){const s=[];for(const{begin:i,end:a,center:l,prevPolygon:c}of e){const d=[c.edgeStart,c.edgeEnd],h=this.getVertexHeightFromEdge(l,d,r,1);s.push(this.getSkirtPart(i,a,l,t,n,h))}return s}getSkirtPart(e,t,n,r,s,i){return{points:[{position:e,height:r},{position:n,height:r+s*i},{position:t,height:r}],hasWindows:!1}}}class Yt extends Je{constructor(){super(...arguments),this.splitProgress=.3,this.edgeBumpFactor=.3}convertSkeletonPolygonToVertices({polygon:e,minHeight:t,height:n,maxSkeletonHeight:r,scaleX:s,scaleY:i}){const a=[e.edgeStart,e.edgeEnd],{verticesBottom:l,verticesTop:c}=Ut(e,r*this.splitProgress);return this.triangulateTopAndBottom({verticesBottom:l,verticesTop:c,minHeight:t,height:n,maxSkeletonHeight:r,edge:a,scaleX:s,scaleY:i})}triangulateTopAndBottom({verticesBottom:e,verticesTop:t,minHeight:n,height:r,maxSkeletonHeight:s,edge:i,scaleX:a,scaleY:l}){const c=this.triangulatePolygon(e,n,r,s,i,a,l,h=>this.calculateRoofHeightBottom(h)),d=this.triangulatePolygon(t,n,r,s,i,a,l,h=>this.calculateRoofHeightTop(h));return{position:c.position.concat(d.position),uv:c.uv.concat(d.uv)}}calculateRoofHeightBottom(e){return e+e/this.splitProgress*this.edgeBumpFactor}calculateRoofHeightTop(e){return e+(1-e)/(1-this.splitProgress)*this.edgeBumpFactor}}class Vr extends Yt{constructor(){super(...arguments),this.splitProgress=.5,this.edgeBumpFactor=0}triangulateTopAndBottom({verticesBottom:e,verticesTop:t,minHeight:n,height:r,maxSkeletonHeight:s,edge:i,scaleX:a,scaleY:l}){const c=this.triangulatePolygon(e,n,r*2,s,i,a,l),d=this.triangulatePolygon(t,n+r,0,s,i,a,l);return{position:c.position.concat(d.position),uv:c.uv.concat(d.uv)}}}class $t{static build({vertices:e,minHeight:t,height:n,heightPoints:r,levels:s,windowWidth:i,textureIdWindow:a,textureIdWall:l,uvOffset:c=new u(0,0)}){let d=!1;e[0].equals(e[e.length-1])&&(e=e.slice(1),d=!0,r&&(r=r.slice(1)));const h=this.getEdgeSmoothness(e,d),f=h.findIndex(S=>!S);if(f>0)for(let S=0;S<f;S++)h.push(h.shift()),e.push(e.shift()),r&&r.push(r.shift());const p=this.getSegmentsNormals(e,d),g=this.getWalls(e,d,h,i),m=this.getWallPositions(e,d,t,n,r),{uvs:x,textureIds:y}=this.getWallUVsAndTextureIds({vertices:e,isClosed:d,height:n,minHeight:t,heightPoints:r,levels:s,textureIdWall:l,textureIdWindow:a,walls:g,uvOffset:c}),M=this.getWallNormals(p,h,d);return{position:m,uv:x,normal:M,textureId:y}}static getNextVertex(e,t,n){const r=e+1;return r>t.length-1?n?t[0]:null:t[r]}static getPreviousVertex(e,t,n){const r=e-1;return r<0?n?t[t.length-1]:null:t[r]}static getEdgeSmoothness(e,t){const n=[];for(let r=0;r<e.length;r++){const s=e[r],i=this.getNextVertex(r,e,t),a=this.getPreviousVertex(r,e,t);if(!i||!a){n.push(!1);continue}const l=u.normalize(u.sub(i,s)),c=u.normalize(u.sub(s,a)),d=u.dot(l,c);n.push(d>Math.cos(I.toRad(J.BuildingSmoothNormalsThreshold)))}return n}static getWalls(e,t,n,r){const s=[],i=t?e.length:e.length-1;let a=0;for(let h=0;h<i;h++){const f=e[h],p=this.getNextVertex(h,e,t);if(!p)break;const g=u.getLength(u.sub(p,f)),m=n[h+1]??n[0];s.push([a,a+g]),m?a+=g:a=0}const l=[];let c=[],d=0;for(let h=0;h<s.length;h++){const f=s[h],p=s[h+1];if(c.push([f[0],f[1],!1]),!p||p[0]===0){const g=c[c.length-1][1],m=Math.round(g/r),x=g/m;if(m>0)for(const y of c)y[0]/=x,y[1]/=x,y[2]=!0;else for(const y of c)y[0]/=r,y[1]/=r,y[2]=!1;for(const y of c)y[0]+=d,y[1]+=d;l.push(...c),c=[],d+=m,d=Math.floor(d)}}return l}static getSegmentsNormals(e,t){const n=[],r=t?e.length:e.length-1;for(let s=0;s<r;s++){const i=e[s],a=this.getNextVertex(s,e,t),l=u.distance(i,a),c=I.calculateNormal(new w(a.x,0,a.y),new w(i.x,0,i.y),new w(i.x,1,i.y));n.push(w.multiplyScalar(c,l))}return n}static getNextSegmentNormal(e,t,n){const r=e+1;return r>t.length-1?n?t[0]:null:t[r]}static getPreviousSegmentNormal(e,t,n){const r=e-1;return r<0?n?t[t.length-1]:null:t[r]}static getWallNormals(e,t,n){const r=[];for(let s=0;s<e.length;s++){const i=e[s],a=w.normalize(e[s]),l=this.getNextSegmentNormal(s,e,n)??i,c=this.getPreviousSegmentNormal(s,e,n)??i,d=[t[s],s===t.length-1?t[0]:t[s+1]],h=[1,0,0,1,0,1];for(let f=0;f<6;f++){const p=h[f];if(d[p]){const g=p===1?l:c;r.push(...w.toArray(w.normalize(w.add(i,g))))}else r.push(a.x,a.y,a.z)}}return r}static getWallPositions(e,t,n,r,s){const i=[],a=t?e.length:e.length-1;for(let l=0;l<a;l++){const c=e[l],d=this.getNextVertex(l,e,t);let h,f;s?(h=s[l],f=s[l+1]??s[0]):(h=r,f=r),i.push(d.x,n,d.y),i.push(c.x,n,c.y),i.push(c.x,h,c.y),i.push(d.x,n,d.y),i.push(c.x,h,c.y),i.push(d.x,f,d.y)}return i}static getWallUVsAndTextureIds({vertices:e,isClosed:t,height:n,minHeight:r,heightPoints:s,levels:i,textureIdWall:a,textureIdWindow:l,walls:c,uvOffset:d}){const h=[],f=[],p=t?e.length:e.length-1;for(let g=0;g<p;g++){let m,x;s?(m=s[g],x=s[g+1]??s[0]):(m=n,x=n),m-=r,x-=r;const[y,M,S]=c[g];let F=Math.max(x,m)/(n-r)*i,R=F;m>x?R*=x/m:x>m&&(F*=m/x),h.push(d.x+M,d.y,d.x+y,d.y,d.x+y,d.y+F),h.push(d.x+M,d.y,d.x+y,d.y+F,d.x+M,d.y+R);const D=S?l:a;for(let N=0;N<6;N++)f.push(D)}return{uvs:h,textureIds:f}}}class Ce{build(e){this.calculateSplitsNormals();const{orientation:t,multipolygon:n,minHeight:r,height:s}=e,i=e.multipolygon.getOMBB(),{rotVector0:a,rotVector1:l,origin:c}=Vt(i,t,this.respectDirection?e.direction:null),d=u.sub(u.add(c,u.multiplyScalar(a,.5)),l),h=[d,u.add(d,a)],f=n.getFootprint({height:0,flip:!1}),p=[],g=[],m=[];for(let y=0;y<f.positions.length;y+=9){const M=f.positions,S=[[M[y],M[y+2]],[M[y+3],M[y+5]],[M[y+6],M[y+8]]],F=this.processTriangle(S,c,a,l,s);for(const R of F)this.processRoofRing(R,r+s*R.heightFrom,s*(R.heightTo-R.heightFrom),h,e.scaleX,e.scaleY,p,g,m)}if(!this.isSmooth){const y=Hr(p);m.push(...y)}const x=this.getSkirt({multipolygon:n,minHeight:r,height:s,origin:c,rotVector0:a,rotVector1:l});return{position:p,normal:m,uv:g,skirt:x,addSkirt:!0,canExtendOutsideFootprint:!0}}processTriangle(e,t,n,r,s){const i=[];let a=0;for(let l=1;l<this.splits.length;l++){const c=this.splits[l],d=this.splits[l-1],h=u.sub(u.add(t,u.multiplyScalar(n,c.x)),r),f=u.add(h,u.multiplyScalar(r,3)),p=[h,f],g=u.getLength(n),m=u.distance(new u(d.x*g,d.y*s),new u(c.x*g,c.y*s)),x=a+m,y=c.y<d.y,M=this.splitsNormals[l-1],S=this.splitsNormals[l],F=g,R=s,D=u.angleClockwise(new u(0,1),r),N=w.rotateAroundAxis(new w(M.x/F,M.y/R,0),new w(0,1,0),-D-Math.PI),O=w.rotateAroundAxis(new w(S.x/F,S.y/R,0),new w(0,1,0),-D-Math.PI);if(l===this.splits.length-1){i.push({vertices:e,line:p,heightFrom:d.y,heightTo:c.y,length:(c.x-d.x)*u.getLength(n),uvYFrom:a,uvYTo:x,flipUV:y,normalFrom:w.normalize(N),normalTo:w.normalize(O)});break}const E=this.splitTriangle(e,p);if(E.verticesBottom.length>0&&i.push({vertices:E.verticesBottom,line:p,heightFrom:d.y,heightTo:c.y,length:(c.x-d.x)*u.getLength(n),uvYFrom:a,uvYTo:x,flipUV:y,normalFrom:w.normalize(N),normalTo:w.normalize(O)}),a=x,E.verticesTop.length>0)e=E.verticesTop;else break}return i}getSplitLine(e,t,n,r){const s=u.sub(u.add(t,u.multiplyScalar(n,e.x)),r),i=u.add(s,u.multiplyScalar(r,3));return[s,i]}processRoofRing(e,t,n,r,s,i,a,l,c){if(e.length)for(let d=2;d<e.vertices.length;d++){const h=[e.vertices[0],e.vertices[d-1],e.vertices[d]];for(const f of h){const p=new u(f[0],f[1]),g=le(p,e.line),m=1-Math.abs(g)/e.length;a.push(f[0],t+m*n,f[1]);let y=le(p,r)/s,M=I.lerp(e.uvYFrom,e.uvYTo,m)/i;if(e.flipUV&&(y*=-1,M*=-1),l.push(y,M),this.isSmooth){const S=w.lerp(e.normalFrom,e.normalTo,m);c.push(S.x,S.y,S.z)}}}}splitTriangle(e,t){const n=e,r=[],s=[];let i=null;try{i=_t(n,u.toArray(t[0]),u.toArray(u.sub(t[0],t[1])))}catch{}!i||i.length===1?r.push(...n):i.length>1&&(r.push(...i[1]),s.push(...i[0]));const a=this.getSplitRingMaxDstToLine(s,t),l=this.getSplitRingMaxDstToLine(r,t),c=s.length!==0&&a>1e-4||r.length!==0&&l<1e-4;return{verticesTop:c?s:r,verticesBottom:c?r:s}}getSplitRingMaxDstToLine(e,t){let n=-1/0;for(let r=0;r<e.length;r++){const[s,i]=e[r],a=le(new u(s,i),t);a>n&&(n=a)}return n}getSkirt({multipolygon:e,minHeight:t,height:n,origin:r,rotVector0:s,rotVector1:i}){const a=[];for(const l of e.rings){const c={points:[],hasWindows:!1};a.push(c);for(let d=0;d<l.nodes.length;d++){const h=l.nodes[d],f=l.nodes[d+1],p=this.getPointHeight(h,r,s,i);if(c.points.push({position:h,height:t+n*Math.abs(p)}),!f)continue;const g=[];for(let m=1;m<this.splits.length-1;m++){const x=this.getSplitLine(this.splits[m],r,s,i),y=I.getIntersectionLineLine([h.x,h.y],[f.x,f.y],[x[0].x,x[0].y],[x[1].x,x[1].y]);if(!y)continue;const M=new u(y[0],y[1]),S=I.getPointProgressAlongLineSegment(h,f,M);g.push({position:M,progress:S})}g.sort((m,x)=>m.progress-x.progress);for(const{position:m}of g){const x=this.getPointHeight(m,r,s,i);c.points.push({position:m,height:t+n*Math.abs(x)})}}}return a}getPointHeight(e,t,n,r){const s=[t,u.add(t,r)],i=le(e,s)/u.getLength(n);for(let a=1;a<this.splits.length;a++)if(i<this.splits[a].x||a===this.splits.length-1){const l=this.splits[a-1],c=this.splits[a];return I.lerp(l.y,c.y,(i-l.x)/(c.x-l.x))}return 0}calculateSplitsNormals(){this.splitsNormals=jt(this.splits)}}class Er extends Ce{constructor(){super(...arguments),this.splits=[new u(0,0),new u(.5,1),new u(1,0)],this.isSmooth=!1,this.respectDirection=!1}}class qr extends $e{constructor(){super(...arguments),this.splits=[new u(0,1),new u(.1111111111111111,1.1470588235294117),new u(.2222222222222222,1.1764705882352942),new u(.3333333333333333,1.1470588235294117),new u(.4444444444444444,1),new u(.5555555555555556,.7647058823529411),new u(.6666666666666666,.4117647058823529),new u(.7777777777777778,.15882352941176472),new u(.8888888888888888,.03529411764705882),new u(1,0)],this.isEdgy=!1}}class _r extends $e{constructor(){super(...arguments),this.splits=[new u(0,1),new u(.17364817766693033,.984807753012208),new u(.3420201433256687,.9396926207859084),new u(.49999999999999994,.8660254037844387),new u(.6427876096865393,.766044443118978),new u(.766044443118978,.6427876096865394),new u(.8660254037844386,.5000000000000001),new u(.9396926207859083,.3420201433256688),new u(.984807753012208,.17364817766693041),new u(1,0)],this.isEdgy=!1}}class jr extends Xt{constructor(){super(...arguments),this.splitProgress=.3,this.edgeBumpFactor=.3}convertSkeletonPolygonToVertices({polygon:e,minHeight:t,height:n,maxSkeletonHeight:r,scaleX:s,scaleY:i}){const{verticesBottom:a,verticesTop:l}=Ut(e,r*this.splitProgress);return this.triangulateTopAndBottom({verticesBottom:a,verticesTop:l,minHeight:t,height:n,maxSkeletonHeight:r,edge:[e.edgeStart,e.edgeEnd],scaleX:s,scaleY:i})}triangulateTopAndBottom({verticesBottom:e,verticesTop:t,minHeight:n,height:r,maxSkeletonHeight:s,edge:i,scaleX:a,scaleY:l}){const c=this.triangulatePolygon(e,n,r,s,i,a,l,h=>this.calculateRoofHeightBottom(h)),d=this.triangulatePolygon(t,n,r,s,i,a,l,h=>this.calculateRoofHeightTop(h));return{position:c.position.concat(d.position),uv:c.uv.concat(d.uv)}}calculateRoofHeightBottom(e){return e+e/this.splitProgress*this.edgeBumpFactor}calculateRoofHeightTop(e){return e+(1-e)/(1-this.splitProgress)*this.edgeBumpFactor}getSkirtPart(e,t,n,r,s,i){const a=this.calculateRoofHeightTop(i)*s,l=this.calculateRoofHeightTop(this.splitProgress)*s;let c;return l>=a?c=[{position:e,height:r},{position:n,height:r+a},{position:t,height:r}]:c=[{position:e,height:r},{position:u.lerp(e,n,this.splitProgress/i),height:r+l},{position:n,height:r+a},{position:u.lerp(t,n,this.splitProgress/i),height:r+l},{position:t,height:r}],{points:c,hasWindows:!1}}}class Ur extends Ce{constructor(){super(...arguments),this.splits=[new u(0,0),new u(.15,.8),new u(.5,1),new u(.85,.8),new u(1,0)],this.isSmooth=!1,this.respectDirection=!1}}class Xr extends Ce{constructor(){super(...arguments),this.splits=[new u(0,0),new u(.00759612349389599,.17364817766693041),new u(.03015368960704584,.3420201433256688),new u(.0669872981077807,.5000000000000001),new u(.116977778440511,.6427876096865394),new u(.17860619515673037,.766044443118978),new u(.25,.8660254037844387),new u(.32898992833716567,.9396926207859084),new u(.41317591116653485,.984807753012208),new u(.5,1),new u(.5868240888334652,.984807753012208),new u(.6710100716628343,.9396926207859084),new u(.75,.8660254037844387),new u(.8213938048432696,.766044443118978),new u(.883022221559489,.6427876096865394),new u(.9330127018922193,.5000000000000001),new u(.9698463103929542,.3420201433256688),new u(.9924038765061041,.17364817766693041),new u(1,0)],this.isSmooth=!0,this.respectDirection=!1}}class Yr extends Ce{constructor(){super(...arguments),this.splits=[new u(0,0),new u(.7,1),new u(1,.2)],this.isSmooth=!1,this.respectDirection=!0}}var X=(o=>(o[o.Flat=0]="Flat",o[o.Gabled=1]="Gabled",o[o.Gambrel=2]="Gambrel",o[o.Hipped=3]="Hipped",o[o.Pyramidal=4]="Pyramidal",o[o.Onion=5]="Onion",o[o.Dome=6]="Dome",o[o.Round=7]="Round",o[o.Skillion=8]="Skillion",o[o.Mansard=9]="Mansard",o[o.QuadrupleSaltbox=10]="QuadrupleSaltbox",o[o.Saltbox=11]="Saltbox",o))(X||{});class $r{constructor(e,t){this.arrays={position:[],uv:[],normal:[],textureId:[],color:[]},this.terrainMaskPositions=[],this.boundingBox=new $,this.osmReference=e,this.multipolygon=t}getAreaToOMBBRatio(){const e=this.multipolygon.getOMBB(),t=I.getPolygonAreaSigned(e);return this.multipolygon.getArea()/t}addWalls({terrainHeight:e,minHeight:t,height:n,skirt:r,levels:s,windowWidth:i,color:a,textureIdWindow:l,textureIdWall:c,windowSeed:d}){const h=t>=n;if(r)for(const{points:f,hasWindows:p}of r){const g=f.map(F=>F.position),m=f.map(F=>F.height);let x=0;for(const F of m)x=Math.max(x,F);let y=(n-t)/s;(y<.01||s===0)&&(y=4);let M=(x-n)/y;p&&M>.5&&(M=Math.round(M));const S=$t.build({vertices:g,minHeight:n,height:x,heightPoints:m,levels:M,windowWidth:i,textureIdWall:c,textureIdWindow:p?l:c});this.addAndPaintGeometry({position:S.position,normal:S.normal,uv:S.uv,color:a,textureId:S.textureId,heightOffset:e})}if(!h){const f=new ae(d);for(const p of this.multipolygon.rings){const g=new u(Math.floor(f.generate()*256),Math.floor(f.generate()*256)),m=$t.build({vertices:p.nodes.slice(),minHeight:t,height:n,levels:s,windowWidth:i,textureIdWall:c,textureIdWindow:l,uvOffset:g});this.addAndPaintGeometry({position:m.position,normal:m.normal,uv:m.uv,color:a,textureId:m.textureId,heightOffset:e})}}if(t>0){const f=new Ye().build({multipolygon:this.multipolygon,buildingHeight:t,height:0,minHeight:t,flip:!0,direction:0,angle:0,orientation:null,scaleX:10,scaleY:10,isStretched:!1});this.addAndPaintGeometry({position:f.position,normal:f.normal,uv:f.uv,color:a,textureId:G.RoofConcrete,heightOffset:e})}else{const f=this.multipolygon.getFootprint({height:0,flip:!1});this.addMaskGeometry(f.positions)}}addRoof(e){let t;switch(e.type){case 8:{t=new Nr;break}case 4:{t=new Wr;break}case 5:{t=new qr;break}case 6:{t=new _r;break}case 3:{t=new Je;break}case 1:{e.orientation==="along"||e.orientation==="across"?t=new Er:t=new Xt;break}case 2:{e.orientation==="along"||e.orientation==="across"?t=new Ur:t=new jr;break}case 9:{t=new Yt;break}case 7:e.orientation||(e.orientation="along"),t=new Xr;break;case 10:{t=new Vr;break}case 11:{e.direction===null&&(e.orientation="along"),t=new Yr;break}default:{t=new Ye;break}}const n=this.buildRoofSafe(t,{multipolygon:this.multipolygon,...e});return this.addAndPaintGeometry({position:n.position,normal:n.normal,uv:n.uv,color:e.color,textureId:e.textureId,heightOffset:e.terrainHeight}),{skirt:n.addSkirt?n.skirt:null,facadeHeightOverride:n.facadeHeightOverride}}buildRoofSafe(e,t){let n=e.build(t);return n===null&&(n=new Ye().build(t)),n}addAndPaintGeometry({position:e,normal:t,uv:n,color:r,textureId:s,heightOffset:i}){this.applyHeightOffsetToVertices(e,i),this.addVerticesToBoundingBox(e);let a=!0;ce(this.arrays.position,e),ce(this.arrays.normal,t),ce(this.arrays.uv,n),typeof s!="number"&&(this.arrays.textureId.push(...s),a=!1);const l=e.length/3,c=Cr(r);for(let d=0;d<l;d++)this.arrays.color.push(...c),a&&this.arrays.textureId.push(s)}addMaskGeometry(e){for(let t=0;t<e.length;t+=3)this.terrainMaskPositions.push(e[t],e[t+2])}addVerticesToBoundingBox(e){const t=new w;for(let n=0;n<e.length;n+=3)t.set(e[n],e[n+1],e[n+2]),this.boundingBox.includePoint(t)}applyHeightOffsetToVertices(e,t){for(let n=1;n<e.length;n+=3)e[n]+=t}getIDBuffer(){const e=new Uint32Array(2),t=this.osmReference.type,n=this.osmReference.id;if(t===q.Way||t===q.Relation){const r=t===q.Way?0:1;e[0]=Math.min(n,4294967295),e[1]=I.shiftLeft(r,19)+I.shiftRight(r,32)}return e}getGeometry(){return{type:"extruded",boundingBox:this.boundingBox,positionBuffer:new Float32Array(this.arrays.position),normalBuffer:new Float32Array(this.arrays.normal),uvBuffer:new Float32Array(this.arrays.uv),textureIdBuffer:new Uint8Array(this.arrays.textureId),colorBuffer:new Uint8Array(this.arrays.color),idBuffer:this.getIDBuffer()}}getTerrainMaskGeometry(){return{type:"mask",positionBuffer:new Float32Array(this.terrainMaskPositions)}}}var Jr=k(8036);const Me=611.4962158203125;class Fe{constructor(e){this.mercatorScale=1,this.terrainMinHeight=0,this.terrainMaxHeight=0,this.multipolygon=null,this.instances=[],this.osmReference=e.osmReference,this.descriptor=e.descriptor,this.rings=e.rings,this.simplify()}simplify(){if(!(this.descriptor.type==="roadwayIntersection"||this.descriptor.type==="building"||this.getMultipolygon().getArea()<5)){for(const n of this.rings)n.nodes=Fe.simplifyNodes(n.nodes);this.multipolygon=null}}setRoadGraph(e){}setMercatorScale(e){this.mercatorScale=e}getMultipolygon(){if(this.multipolygon===null){this.multipolygon=new Gt;for(const e of this.rings){const t=e.type===W.Inner?j.Inner:j.Outer,n=e.nodes.map(r=>new u(r.x,r.y));this.multipolygon.addRing(new Lt(t,n))}this.descriptor.ombb&&this.multipolygon.setOMBB(this.descriptor.ombb),this.descriptor.poi&&this.multipolygon.setPoleOfInaccessibility(this.descriptor.poi)}return this.multipolygon}getRequestedHeightPositions(){if(this.descriptor.type==="building"||this.descriptor.type==="buildingPart"){const e=[];for(const t of this.rings)for(const n of t.nodes)e.push(n.x,n.y);return{positions:new Float64Array(e),callback:t=>{let n=1/0,r=-1/0;for(let s=0;s<t.length;s++)n=Math.min(n,t[s]),r=Math.max(r,t[s]);this.terrainMinHeight=n,this.terrainMaxHeight=r}}}if(this.descriptor.type==="forest"){const e=this.getMultipolygon().populateWithPoints(Math.floor(40/this.mercatorScale),J.TileSize),t=[],n=[];for(const r of e)r.x<0||r.y<0||r.x>Me||r.y>Me||(n.push(r.x,r.y),t.push(new w(r.x,0,r.y)));return{positions:new Float64Array(n),callback:r=>{for(let s=0;s<t.length;s++){const i=t[s].x,a=r[s],l=t[s].z;this.instances.push(this.createTree(i,a,l))}}}}if(this.descriptor.type==="shrubbery"){const e=this.getMultipolygon().populateWithPoints(Math.floor(80/this.mercatorScale),J.TileSize),t=[],n=[];for(const r of e)r.x<0||r.y<0||r.x>Me||r.y>Me||(n.push(r.x,r.y),t.push(new w(r.x,0,r.y)));return{positions:new Float64Array(n),callback:r=>{for(let s=0;s<t.length;s++){const i=t[s].x,a=r[s],l=t[s].z;this.instances.push(this.createShrub(i,a,l))}}}}if(this.descriptor.type==="construction"){const e=this.getMultipolygon().getPoleOfInaccessibility();if(e.x<0||e.y<0||e.x>Me||e.y>Me)return null;let t=null;if(e.z>12*this.mercatorScale&&(t="trackedCrane"),e.z>32*this.mercatorScale&&(t="towerCrane"),t)return{positions:new Float64Array([e.x,e.y]),callback:n=>{const r=this.createGenericInstance(e.x,n[0],e.y,t);this.instances.push(r)}}}return null}getFeatures(){switch(this.descriptor.type){case"building":case"buildingPart":return this.handleBuilding();case"water":return this.handleGenericSurface({textureId:L.Water,isOriented:!1,zIndex:z.Water});case"pitch":{const t={football:L.FootballPitch,basketball:L.BasketballPitch,tennis:L.TennisCourt,generic:L.GenericPitch}[this.descriptor.pitchType];return t===L.GenericPitch?this.handleGenericSurface({textureId:t,isOriented:!1,uvScale:20,zIndex:z.Pitch}):this.handleGenericSurface({textureId:t,isOriented:!0,stretch:!0,zIndex:z.Pitch})}case"manicuredGrass":return this.handleGenericSurface({textureId:L.ManicuredGrass,isOriented:!1,zIndex:z.ManicuredGrass,uvScale:20});case"garden":return this.handleGenericSurface({textureId:L.Garden,isOriented:!1,zIndex:z.Garden,uvScale:16});case"construction":{const e=this.handleGenericSurface({textureId:L.Soil,isOriented:!1,zIndex:z.Construction,uvScale:25});return e.push(...this.instances),e}case"buildingConstruction":return this.handleGenericSurface({textureId:L.Soil,isOriented:!1,zIndex:z.Construction,uvScale:25});case"grass":return this.handleGenericSurface({textureId:L.Grass,isOriented:!1,zIndex:z.Grass,uvScale:25});case"rock":return this.handleGenericSurface({textureId:L.Rock,isOriented:!1,zIndex:z.Rock,uvScale:32});case"sand":return this.handleGenericSurface({textureId:L.Sand,isOriented:!1,zIndex:z.Sand,uvScale:12});case"farmland":{const e=new ae(this.osmReference.id),t=3,n=Math.floor(e.generate()*t);return this.handleGenericSurface({textureId:L.Farmland0+n,isOriented:!0,stretch:!1,orientation:Oe.Across,zIndex:z.Farmland,uvScale:50})}case"asphalt":return this.handleGenericSurface({textureId:L.Asphalt,isOriented:!1,zIndex:z.AsphaltArea,uvScale:20,addUsageMask:!0});case"roadwayArea":return this.handleGenericSurface({textureId:L.Asphalt,isOriented:!1,zIndex:z.RoadwayArea,uvScale:20,addUsageMask:!0});case"roadwayIntersection":return this.handleRoadIntersection();case"pavement":return this.handleGenericSurface({textureId:L.Pavement,isOriented:!1,zIndex:z.FootwayArea,uvScale:10});case"helipad":return[...this.handleGenericSurface({textureId:L.Helipad,isOriented:!0,stretch:!0,zIndex:z.Helipad}),...this.handleGenericSurface({textureId:L.Pavement,isOriented:!1,zIndex:z.FootwayArea,uvScale:10})];case"forest":return this.instances;case"shrubbery":return[...this.instances,...this.handleGenericSurface({textureId:L.ForestFloor,isOriented:!1,zIndex:z.ShrubberySoil,uvScale:15})]}return[]}handleRoadIntersection(){const e={asphalt:{textureId:L.Asphalt,scale:20},concrete:{textureId:L.ConcreteIntersection,scale:20},cobblestone:{textureId:L.Cobblestone,scale:6}},{textureId:t,scale:n}=e[this.descriptor.intersectionMaterial]??e.asphalt;return this.handleGenericSurface({textureId:t,isOriented:!1,zIndex:z.AsphaltArea,uvScale:n,addUsageMask:!0})}handleBuilding(){const e=this.getMultipolygon(),t=new $r(this.osmReference,e),n=t.getAreaToOMBBRatio()<.75||e.getArea()<10,r=this.getRoofParams(n),s=this.descriptor.buildingFoundation?this.terrainMaxHeight:this.terrainMinHeight,i=this.terrainMaxHeight-this.terrainMinHeight,{skirt:a,facadeHeightOverride:l}=t.addRoof({terrainHeight:s,type:r.type,buildingHeight:this.descriptor.buildingHeight,minHeight:this.descriptor.buildingHeight-this.descriptor.buildingRoofHeight,height:this.descriptor.buildingRoofHeight,direction:this.descriptor.buildingRoofDirection,orientation:this.descriptor.buildingRoofOrientation,angle:this.descriptor.buildingRoofAngle,textureId:r.textureId,color:r.color,scaleX:r.scaleX,scaleY:r.scaleY,isStretched:r.isStretched,flip:!1}),c=this.getFacadeParams();t.addWalls({terrainHeight:s,levels:this.descriptor.buildingLevels,windowWidth:c.windowWidth,minHeight:this.descriptor.buildingMinHeight,height:l??this.descriptor.buildingHeight-this.descriptor.buildingRoofHeight,skirt:a,color:c.color,textureIdWall:c.textureIdWall,textureIdWindow:c.textureIdWindow,windowSeed:this.osmReference.id}),this.descriptor.buildingFoundation&&i>.5&&t.addWalls({terrainHeight:this.terrainMinHeight,levels:i/4,windowWidth:c.windowWidth,minHeight:0,height:this.terrainMaxHeight-this.terrainMinHeight,skirt:null,color:c.color,textureIdWall:c.textureIdWall,textureIdWindow:c.textureIdWall,windowSeed:this.osmReference.id});const d=[t.getGeometry(),t.getTerrainMaskGeometry()];if(this.descriptor.label){const h=this.getMultipolygon().getPoleOfInaccessibility(),f=s+this.descriptor.buildingHeight+5,p={type:"label",position:[h.x,f,h.y],priority:h.z,text:this.descriptor.label};d.push(p)}return d}handleGenericSurface({textureId:e,isOriented:t,uvScale:n=1,stretch:r=!1,orientation:s=Oe.Along,zIndex:i,addUsageMask:a=!1}){const l=new Ie(this.getMultipolygon());l.setZIndex(i),l.addPolygon({height:0,textureId:e,isOriented:t,orientation:s,stretch:r,uvScale:n,addUsageMask:a});const c=[l.getGeometry()];return a&&c.push(l.getTerrainMaskGeometry()),c}createTree(e,t,n){const r=Math.floor(e)+Math.floor(n),s=new ae(r),i=s.generate()*Math.PI*2,a=Rt(this.descriptor.treeType),l=a[Math.floor(s.generate()*a.length)],c=Bt(l),d=Pt(l),h=d[0]+s.generate()*(d[1]-d[0]);return{type:"instance",instanceType:"tree",x:e,y:t*this.mercatorScale,z:n,scale:h*c*this.mercatorScale,rotation:i,seed:s.generate(),textureId:l}}createShrub(e,t,n){const r=Math.floor(e)+Math.floor(n),s=new ae(r),i=.9+s.generate()*.25,a=s.generate()*Math.PI*2;return{type:"instance",instanceType:"shrubbery",x:e,y:t*this.mercatorScale,z:n,scale:i*this.mercatorScale,rotation:a}}createGenericInstance(e,t,n,r){const s=Math.floor(e)+Math.floor(n),a=new ae(s).generate()*Math.PI*2;return{type:"instance",instanceType:r,x:e,y:t*this.mercatorScale,z:n,scale:this.mercatorScale,rotation:a}}static getRoofTypeFromString(e){switch(e){case"flat":return X.Flat;case"gabled":return X.Gabled;case"gambrel":return X.Gambrel;case"hipped":return X.Hipped;case"pyramidal":return X.Pyramidal;case"onion":return X.Onion;case"dome":return X.Dome;case"round":return X.Round;case"skillion":return X.Skillion;case"mansard":return X.Mansard;case"quadrupleSaltbox":return X.QuadrupleSaltbox;case"saltbox":return X.Saltbox}return console.error(`Roof type ${e} is not supported`),X.Flat}getRoofParams(e){const t=Fe.getRoofTypeFromString(this.descriptor.buildingRoofType),n=this.descriptor.buildingRoofMaterial;let r=this.descriptor.buildingRoofColor;const s={default:G.RoofConcrete,tiles:G.RoofTiles,metal:G.RoofMetal,concrete:G.RoofConcrete,thatch:G.RoofThatch,eternit:G.RoofEternit,grass:G.RoofGrass,glass:G.RoofGlass,tar:G.RoofTar},i={[G.RoofTiles]:new u(3,3),[G.RoofMetal]:new u(4,4),[G.RoofConcrete]:new u(10,10),[G.RoofThatch]:new u(8,8),[G.RoofEternit]:new u(5,5),[G.RoofGrass]:new u(12,12),[G.RoofGlass]:new u(4,4),[G.RoofTar]:new u(4,4)};if(t===X.Flat&&n==="default"&&!e){const c=[G.RoofGeneric1,G.RoofGeneric2,G.RoofGeneric3,G.RoofGeneric4];return{type:t,textureId:c[(this.osmReference.id||0)%c.length],color:r,scaleX:1,scaleY:1,isStretched:!0}}e&&n==="default"&&(r=12303291);const a=s[n],l=i[a]??new u(1,1);return{type:t,textureId:a,color:r,scaleX:l.x,scaleY:l.y,isStretched:!1}}getFacadeParams(){const e=this.descriptor.buildingFacadeMaterial;let t=this.descriptor.buildingFacadeColor;const n=this.descriptor.buildingWindows,r={plaster:{wall:G.FacadePlasterWall,window:G.FacadePlasterWindow,width:4},glass:{wall:G.FacadeGlass,window:G.FacadeGlass,width:4},brick:{wall:G.FacadeBrickWall,window:G.FacadeBrickWindow,width:4},wood:{wall:G.FacadeWoodWall,window:G.FacadeWoodWindow,width:4},cementBlock:{wall:G.FacadeBlockWall,window:G.FacadeBlockWindow,width:4}},s=r[e]??r.plaster;return{windowWidth:s.width*this.mercatorScale,color:t,textureIdWall:s.wall,textureIdWindow:n?s.window:s.wall}}static simplifyNodes(e){return Jr(e,.5,!1)}}class Zr{constructor(e){this.next=null,this.prev=null,this.intersection=null,this.vector=e}setIntersection(e){this.intersection&&console.warn("Overwriting existing intersection"),this.intersection=e}getIntersection(){return this.intersection}}class Qr{constructor(e,t){this.vertices=[],this.startVertex=null,this.endVertex=null,this.width=t;const n=e[0].equals(e[e.length-1]),r=e.length-(n?1:0);for(let a=0;a<r;a++){const l=new Zr(e[a]);if(this.vertices.length>0){const c=this.vertices[this.vertices.length-1];l.prev=c,c.next=l}this.vertices.push(l)}const s=this.vertices[0],i=this.vertices[this.vertices.length-1];n?(i.next=s,s.prev=i):(this.startVertex=s,this.endVertex=i)}get start(){return this.startVertex}get end(){return this.endVertex}}class ve{constructor(e,t){this.point=e,this.isProjected=t,this.alpha=0}}class Kr{constructor(e,t,n){this.segmentLeftIntersections=[],this.segmentRightIntersections=[],this.trimTo=null,this.start=e,this.end=t,this.width=n;const r=u.normalize(u.sub(e,t));this.leftDirection=u.rotateLeft(r),this.rightDirection=u.rotateRight(r),this.segmentLeft=[u.add(e,u.multiplyScalar(this.leftDirection,this.width/2)),u.add(t,u.multiplyScalar(this.leftDirection,this.width/2))],this.segmentRight=[u.add(e,u.multiplyScalar(this.rightDirection,this.width/2)),u.add(t,u.multiplyScalar(this.rightDirection,this.width/2))],this.angle=r.getAngle(),this.segmentLeftIntersections.push(new ve(this.segmentLeft[1],!0)),this.segmentRightIntersections.push(new ve(this.segmentRight[1],!0)),this.segmentLeft[0]=u.add(this.segmentLeft[0],u.multiplyScalar(r,this.width)),this.segmentRight[0]=u.add(this.segmentRight[0],u.multiplyScalar(r,this.width)),this.segmentLeft[1]=u.add(this.segmentLeft[1],u.multiplyScalar(r,-16)),this.segmentRight[1]=u.add(this.segmentRight[1],u.multiplyScalar(r,-16))}projectIntersections(){for(const e of this.segmentLeftIntersections)e.isProjected||this.segmentRightIntersections.push(new ve(u.add(e.point,u.multiplyScalar(this.rightDirection,this.width)),!0));for(const e of this.segmentRightIntersections)e.isProjected||this.segmentLeftIntersections.push(new ve(u.add(e.point,u.multiplyScalar(this.leftDirection,this.width)),!0))}updateIntersectionsAlpha(){this.updateIntersectionsAlphaForSide(this.segmentRightIntersections,this.segmentRight),this.updateIntersectionsAlphaForSide(this.segmentLeftIntersections,this.segmentLeft)}updateIntersectionsAlphaForSide(e,t){for(const n of e)n.alpha=I.getPointProgressAlongLineSegment(t[0],t[1],n.point)}sortIntersectionsByAlpha(){const e=(t,n)=>t.alpha-n.alpha;this.segmentLeftIntersections.sort(e),this.segmentRightIntersections.sort(e)}getTrimmedEnd(){if(!this.trimTo)return this.end;const e=I.getPointProgressAlongLineSegment(this.start,this.end,this.trimTo.point,!0);return u.lerp(this.start,this.end,e)}}class es{constructor(e){this.segments=[],this.center=e}addDirection(e,t){const n=new Kr(e,this.center,t);return this.segments.push(n),n}getPolygon(){if(this.segments.length<3)throw new Error("Intersection must have at least 3 directions");this.sortSegments();for(let t=0;t<this.segments.length;t++){const n=this.segments[t],r=this.segments[(t+1)%this.segments.length],s=n.segmentLeft,i=r.segmentRight,a=I.getIntersectionLineLine(u.toArray(s[0]),u.toArray(s[1]),u.toArray(i[0]),u.toArray(i[1]));if(a){const l=new u(a[0],a[1]);n.segmentLeftIntersections.push(new ve(l,!1)),r.segmentRightIntersections.push(new ve(l,!1))}}for(const t of this.segments)t.projectIntersections(),t.updateIntersectionsAlpha(),t.sortIntersectionsByAlpha();const e=[];for(const t of this.segments){const n=t.segmentRightIntersections[0],r=t.segmentLeftIntersections[0];if(n.isProjected){const s=t.segmentRightIntersections.find(i=>!i.isProjected);s&&e.push(s.point)}if(e.push(n.point),e.push(r.point),r.isProjected){const s=t.segmentLeftIntersections.find(i=>!i.isProjected);s&&e.push(s.point)}t.trimTo=n}return e}sortSegments(){this.segments.sort((e,t)=>e.angle-t.angle)}}class ts{constructor(e){this.directions=[],this.userData={},this.center=e}addDirection(e,t){const n={road:e,vertex:t};this.directions.push(n)}getPolygon(){const e=new es(this.center),t=[];for(const r of this.directions){const s=e.addDirection(r.vertex.vector,r.road.width);t.push(s)}const n=e.getPolygon();for(let r=0;r<t.length;r++)this.directions[r].trimmedEnd=t[r].getTrimmedEnd();return n}}class ns{constructor(e,t){this.start=e,this.end=t}getProjectionOnSegment(e){const t=u.sub(e,this.start),n=u.sub(this.end,this.start),r=t.x*n.x+t.y*n.y,s=n.x*n.x+n.y*n.y,i=s===0?0:Math.max(0,Math.min(1,r/s)),a=this.start.x+i*n.x,l=this.start.y+i*n.y;return new u(a,l)}}class rs{constructor(){this.segments=[]}addSegmentsFromVertices(e){for(let t=1;t<e.length;t++)this.segments.push(new ns(e[t-1],e[t]))}getClosestProjection(e){let t=null,n=1/0;for(const r of this.segments){const s=r.getProjectionOnSegment(e),i=u.distance(e,s);i<n&&(t=s,n=i)}return t}}var ss=k(46725),os=k.n(ss);class is{constructor(){this.groups=new Map,this.segmentGroups=new Map}addRoad(e,t,n){const r=this.getGroup(n),s=new Qr(e,t);return r.roads.push(s),this.getSegmentGroup(n).addSegmentsFromVertices(e),s}getGroup(e){return this.groups.has(e)||this.groups.set(e,{roads:[],intersections:[]}),this.groups.get(e)}getSegmentGroup(e){return this.segmentGroups.has(e)||this.segmentGroups.set(e,new rs),this.segmentGroups.get(e)}initIntersections(){for(const e of this.groups.values()){const t=new(os());for(const n of e.roads)for(const r of n.vertices){const s=r.vector,i=t.search({minX:s.x-.01,minY:s.y-.01,maxX:s.x+.01,maxY:s.y+.01});i.length>0?i[0].data.push([r,n]):t.insert({minX:s.x,minY:s.y,maxX:s.x,maxY:s.y,data:[[r,n]]})}for(const n of t.all()){const r=n.data;if(r.length<2)continue;const s=r[0][0].vector,i=new ts(s);for(const[a,l]of r){const c=a.next,d=a.prev;c&&i.addDirection(l,c),d&&i.addDirection(l,d),a.setIntersection(i)}i.directions.length>1&&e.intersections.push(i)}}}buildIntersectionPolygons(e){const t=this.getGroup(e),n=[];for(const r of t.intersections)r.directions.length>2&&n.push({intersection:r,polygon:r.getPolygon()});return n}getClosestProjectionGlobal(e){let t=null,n=1/0;for(const r of this.segmentGroups.values()){const s=r.getClosestProjection(e);if(!s)continue;const i=u.distance(e,s);i<n&&(t=s,n=i)}return t}getClosestProjection(e,t){if(t!==void 0){const n=this.getSegmentGroup(t);return n?n.getClosestProjection(e):null}return this.getClosestProjectionGlobal(e)}}class as{constructor(e,t){this.start=e,this.end=t}}var Z=(o=>(o[o.Tower=0]="Tower",o[o.Pole=1]="Pole",o[o.Ground=2]="Ground",o))(Z||{});class Jt{constructor(e,t){this.vector=u.normalize(u.sub(t,e))}}class Zt{constructor(e,t){this.directions=[],this.rotation=0,this.type=e,this.position=t}addSegment(e){let t=null;e.start.position.equals(this.position)?t=new Jt(this.position,e.end.position):e.end.position.equals(this.position)&&(t=new Jt(this.position,e.start.position)),t!==null&&this.directions.push(t)}updateRotation(){if(this.directions.length===0)return;if(this.directions.length===1){const t=this.directions[0].vector;this.rotation=-t.getAngle()+Math.PI/2;return}let e=new u(0,0);for(const t of this.directions)e=u.add(e,t.vector);e=u.normalize(e),!(u.getLength(e)<.5)&&(this.rotation=-e.getAngle())}}class fe{constructor(){this.segmentInputs=[],this.nodeInputs=[],this.nodesMap=new Map,this.segments=[],this.entities=null}addPowerlinePolyline(e){for(let t=0;t<e.length-1;t++)this.segmentInputs.push([e[t],e[t+1]])}addPowerlineNode(e,t){this.nodeInputs.push([e,t])}addNode(e){const t=`${e.position.x},${e.position.y}`;this.nodesMap.set(t,e)}getNode(e){const t=`${e.x},${e.y}`;return this.nodesMap.get(t)}processGraph(){for(const[e,t]of this.nodeInputs)this.addNode(new Zt(e,t));for(const[e,t]of this.segmentInputs){const n=this.getNode(e)??fe.getPlaceholderNode(e),r=this.getNode(t)??fe.getPlaceholderNode(t),s=new as(n,r);this.segments.push(s),n.type!==Z.Ground&&n.addSegment(s),r.type!==Z.Ground&&r.addSegment(s)}for(const e of this.nodesMap.values())e.updateRotation()}createEntities(){const e={nodes:[],segments:[]};for(const t of this.nodesMap.values())e.nodes.push(fe.getNodeEntity(t));for(const t of this.segments)e.segments.push({start:fe.getNodeEntity(t.start),end:fe.getNodeEntity(t.end)});this.entities=e}static getNodeEntity(e){return{position:e.position,type:e.type,rotation:e.rotation}}static getPlaceholderNode(e){return new Zt(Z.Ground,e)}}const Qt={[Z.Tower]:[new w(-8.6597,-.003158,20.2559),new w(-6.7063,-0,27.766),new w(7.00047,-0,27.766),new w(8.94836,-.003158,20.2559),new w(.142055,-.040781,20.2559)],[Z.Pole]:[new w(-1,-2e-6,9.00998),new w(-.5,-2e-6,9.00998),new w(.5,-2e-6,9.00998),new w(1,-2e-6,9.00998)],[Z.Ground]:[new w(-1,0,0),new w(-.5,0,0),new w(.5,0,0),new w(1,0,0),new w(0,0,0)]},ls=50;class cs{build(e,t,n,r){const s=[],i=new w(e.start.position.x,t,e.start.position.y),a=new w(e.end.position.x,n,e.end.position.y),l=e.start.type,c=e.end.type;if(l===Z.Ground&&c===Z.Ground)return[];let d=e.start.rotation,h=e.end.rotation;this.dotProduct(d,h)<0&&(h=h+Math.PI);const p=Qt[l],g=Qt[c],m=Math.min(p.length,g.length);for(let x=0;x<m;x++){const y=p[x],M=g[x],S=w.multiplyScalar(new w(y.x,y.z,y.y),r),F=w.multiplyScalar(new w(M.x,M.z,M.y),r),R=w.rotateAroundAxis(S,new w(0,1,0),d),D=w.rotateAroundAxis(F,new w(0,1,0),h),N=w.add(i,R),O=w.add(a,D),E=this.createWireSegment(N,O,r);s.push(E)}return s}dotProduct(e,t){const n=[Math.cos(e),Math.sin(e)],r=[Math.cos(t),Math.sin(t)];return n[0]*r[0]+n[1]*r[1]}vectorToEulerRotation(e){const{x:t,y:n,z:r}=e,s=Math.atan2(t,r),i=Math.atan2(-n,Math.sqrt(t*t+r*r));return new w(i,s,0)}createWireSegment(e,t,n){const r=w.normalize(w.sub(t,e)),s=this.vectorToEulerRotation(r),i=w.lerp(e,t,.5),a=w.distance(e,t)/ls;return{type:"instance",instanceType:"wire",x:i.x,y:i.y,z:i.z,scaleX:a,scaleY:n,scaleZ:n,rotationX:0,rotationY:s.y+Math.PI/2,rotationZ:s.x}}}class ze{constructor(e){this.graph=new fe,this.mercatorScale=1,this.heightMap=null;for(const t of e.nodes)t.descriptor.type==="utilityPole"?this.graph.addPowerlineNode(Z.Pole,new u(t.x,t.y)):t.descriptor.type==="transmissionTower"&&this.graph.addPowerlineNode(Z.Tower,new u(t.x,t.y));for(const t of e.polylines)if(t.descriptor.type==="powerLine"){const n=t.nodes.map(r=>new u(r.x,r.y));this.graph.addPowerlinePolyline(n)}this.graph.processGraph(),this.graph.createEntities()}buildInstances(){const e=[];for(const t of this.graph.entities.nodes){const n=this.getInstanceFromGraphNode(t);n&&e.push(n)}for(const t of this.graph.entities.segments){const n=this.getInstancesFromGraphSegment(t);e.push(...n)}return e}getFeatures(){return this.buildInstances()}getRequestedHeightPositions(){const e=new Map;for(const n of this.graph.entities.segments)for(const{position:r}of[n.end,n.start]){const s=`${r.x},${r.y}`;e.has(s)||e.set(s,r)}for(const{position:n}of this.graph.entities.nodes){const r=`${n.x},${n.y}`;e.has(r)||e.set(r,n)}const t=[];for(const n of e.values())t.push(n.x,n.y);return{positions:new Float64Array(t),callback:n=>{const r=new Map;for(let s=0;s<n.length;s++){const i=t[s*2],a=t[s*2+1],l=`${i},${a}`;r.set(l,n[s])}this.heightMap=r}}}setMercatorScale(e){this.mercatorScale=e}setRoadGraph(e){}getInstanceFromGraphNode(e){if(ze.isOutOfBounds(e.position.x,e.position.y))return null;const t=e.type===Z.Tower?"transmissionTower":"utilityPole",n=this.heightMap.get(`${e.position.x},${e.position.y}`);return{type:"instance",instanceType:t,x:e.position.x,y:n*this.mercatorScale,z:e.position.y,scale:this.mercatorScale,rotation:e.rotation}}getInstancesFromGraphSegment(e){const t=e.start.position,n=e.end.position,r=this.heightMap.get(`${t.x},${t.y}`),s=this.heightMap.get(`${n.x},${n.y}`),i=new cs().build(e,r*this.mercatorScale,s*this.mercatorScale,this.mercatorScale);for(const a of i);return i.filter(a=>!ze.isOutOfBounds(a.x,a.z))}static isOutOfBounds(e,t){const n=611.4962158203125;return e<0||e>n||t<0||t>n}}class ue{constructor(e){this.params=e,this.vectorProvider=new Sr(e)}async getCollection({x:e,y:t,zoom:n}){const r=await this.vectorProvider.getCollection({x:e,y:t,zoom:n});ue.transformVectorFeaturesToWorldSpace(r,e,t,n);const s=ue.createHandlersFromVectorFeatureCollection(r);ue.updateFeaturesMercatorScale(s,e,t,n),await ue.updateFeaturesHeight(s,this.params.heightPromise),ue.addRoadGraphToHandlers(s);const i=ue.getCollectionFromHandlers(e,t,n,s);return kr(i.extruded,e,t,n),i}static createHandlersFromVectorFeatureCollection(e){const t=[];for(const n of e.nodes)t.push(new Fr(n));for(const n of e.polylines)t.push(new he(n));for(const n of e.areas)t.push(new Fe(n));return t.push(new ze(e)),t}static transformVectorFeaturesToWorldSpace(e,t,n,r){const s=4007501668e-2/(1<<r);for(const i of e.nodes)this.transformVectorNodeToWorldSpace(i,s);for(const i of e.polylines)for(const a of i.nodes)this.transformVectorNodeToWorldSpace(a,s);for(const i of e.areas){i.descriptor.ombb&&this.transformOMBBToWorldSpace(i,t,n,r),i.descriptor.poi&&this.transformPOIToWorldSpace(i,t,n,r);for(const a of i.rings)for(const l of a.nodes)this.transformVectorNodeToWorldSpace(l,s)}}static transformOMBBToWorldSpace(e,t,n,r){const s=e.descriptor.ombb,i=[new u,new u,new u,new u],a=4007501668e-2,l=a/(1<<r),c=l*t,d=l*n;for(let h=0;h<s.length;h++){const f=l-(s[h].y*a-d),p=s[h].x*a-c;i[h].set(f,p)}[i[1],i[3]]=[i[3],i[1]],e.descriptor.ombb=i}static transformPOIToWorldSpace(e,t,n,r){const s=e.descriptor.poi,i=4007501668e-2,a=i/(1<<r),l=a*t,c=a*n,d=a-(s.y*i-c),h=s.x*i-l,f=s.z*i;e.descriptor.poi=new w(d,h,f)}static transformVectorNodeToWorldSpace(e,t){const n=e.x,r=e.y;e.x=t-r,e.y=n}static addRoadGraphToHandlers(e){const t=new is,n=new Map;for(const r of e)if(r.setRoadGraph(t),r instanceof he){const s=r.getGraphRoad();s!==null&&n.set(s,r.getIntersectionMaterial())}t.initIntersections(),this.addIntersectionPolygonsToHandlers(t,e,n)}static addIntersectionPolygonsToHandlers(e,t,n){const r=e.buildIntersectionPolygons(0);for(const{intersection:s,polygon:i}of r){const a=this.getIntersectionMaterial(s,n);if(a===null){s.userData.skip=!0;continue}i.push(i[0]),i.reverse(),t.push(new Fe({type:"area",descriptor:{type:"roadwayIntersection",intersectionMaterial:a},rings:[{nodes:i.map(l=>({type:"node",osmReference:null,descriptor:null,x:l.x,y:l.y,rotation:0})),type:W.Outer}],osmReference:null}))}}static getIntersectionMaterial(e,t){const n={asphalt:0,concrete:0,cobblestone:0};let r=0;for(const i of e.directions){const a=t.get(i.road);a!==null&&(++n[a],++r)}if(r<3)return null;const s=Object.entries(n).sort((i,a)=>a[1]-i[1]);return s[0][1]===0?null:s[0][0]}static getCollectionFromHandlers(e,t,n,r){const s={x:e,y:t,zoom:n,extruded:[],projected:[],hugging:[],terrainMask:[],labels:[],instances:[]};for(const i of r){const a=i.getFeatures();if(a){for(const l of a)if(l!==null)switch(l.type){case"instance":s.instances.push(l);break;case"projected":s.projected.push(l);break;case"extruded":s.extruded.push(l);break;case"hugging":s.hugging.push(l);break;case"mask":s.terrainMask.push(l);break;case"label":s.labels.push(l);break}}}return s}static updateFeaturesMercatorScale(e,t,n,r){const s=I.getMercatorScaleFactorForTile(t,n,r);for(const i of e)i.setMercatorScale(s)}static async updateFeaturesHeight(e,t){const n=[];for(const d of e){const h=d.getRequestedHeightPositions();h&&n.push(h)}const r=[],s=[];let i=0;for(const d of n)i+=d.positions.length/2,s.push(i),r.push(d.positions);const a=V.mergeTypedArrays(Float64Array,r),l=await t(a),c=this.splitHeightArray(l,s);for(let d=0;d<c.length;d++)n[d].callback(c[d])}static splitHeightArray(e,t){const n=[];let r=0;for(let s=0;s<t.length;s++){const i=t[s];n.push(e.slice(r,i)),r=i}return n}}var us=(o=>(o[o.Generic=0]="Generic",o[o.Tree=1]="Tree",o[o.Advanced=2]="Advanced",o))(us||{});const ds={[0]:{componentsPerInstance:5,getComponents(o){return[o.x,o.y,o.z,o.scale,o.rotation]},transformBoundingBox(o,e){const[t,n,r,s,i]=e;return o.scaleScalar(s).rotate2D(i).move(t,n,r)}},[1]:{componentsPerInstance:6,getComponents(o){return[o.x,o.y,o.z,o.scale,o.rotation,o.textureId]},transformBoundingBox(o,e){const[t,n,r,s,i]=e;return o.scaleScalar(s).rotate2D(i).move(t,n,r)}},[2]:{componentsPerInstance:9,getComponents(o){return[o.x,o.y,o.z,o.scaleX,o.scaleY,o.scaleZ,o.rotationX,o.rotationY,o.rotationZ]},transformBoundingBox(o,e){const[t,n,r,s,i,a,l,c,d]=e;return o.scale(s,i,a).rotateEuler(l,c,d).move(t,n,r)}}},hs={tree:{structure:1,LOD0MaxDistance:2e3,LOD1MaxDistance:5e3,LOD1Fraction:.5},shrubbery:{structure:0,LOD0MaxDistance:1200,LOD1MaxDistance:2500,LOD1Fraction:.5},adColumn:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},transmissionTower:{structure:0,LOD0MaxDistance:3e3,LOD1MaxDistance:0,LOD1Fraction:0},utilityPole:{structure:0,LOD0MaxDistance:3e3,LOD1MaxDistance:0,LOD1Fraction:0},wire:{structure:2,LOD0MaxDistance:3e3,LOD1MaxDistance:0,LOD1Fraction:0},hydrant:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},trackedCrane:{structure:0,LOD0MaxDistance:2e3,LOD1MaxDistance:0,LOD1Fraction:0},towerCrane:{structure:0,LOD0MaxDistance:3e3,LOD1MaxDistance:0,LOD1Fraction:0},bench:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},picnicTable:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},busStop:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},windTurbine:{structure:0,LOD0MaxDistance:5e3,LOD1MaxDistance:0,LOD1Fraction:0},memorial:{structure:0,LOD0MaxDistance:2e3,LOD1MaxDistance:0,LOD1Fraction:0},statueSmall:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},statueBig:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0},sculpture:{structure:0,LOD0MaxDistance:1e3,LOD1MaxDistance:0,LOD1Fraction:0}},fs=(o,e)=>{let t=new Array(e),n=o.length,r=new Array(n);if(e>n)throw new RangeError("getRandom: more elements taken than available");for(;e--;){const s=Math.floor(Math.random()*n);t[e]=o[s in r?r[s]:s],r[s]=--n in r?r[n]:n}return t};class Ze{static convert(e){return{extruded:this.getExtrudedBuffers(e.extruded),projected:this.getProjectedBuffers(e.projected),hugging:this.getHuggingBuffers(e.hugging),terrainMask:this.getTerrainMaskBuffers(e.terrainMask,e.zoom),labels:this.getLabelsBuffers(e.labels),instances:this.getInstanceBuffers(e.instances)}}static mergeExtrudedGeometriesWithSameOsmRef(e){const t=new Map;for(const r of e){const s=r.idBuffer[0];t.has(s)||t.set(s,[]),t.get(s).push(r)}const n=[];for(const r of e){const s=r.idBuffer[0],i=t.get(s);if(!i.includes(r))continue;const a=i.filter(l=>l!==r).filter(l=>l.idBuffer[1]===r.idBuffer[1]);if(a.length!==0)for(const l of a)this.mergeExtrudedGeometries(r,l),i.splice(i.indexOf(l),1),n.push(l)}for(const r of n)e.splice(e.indexOf(r),1)}static mergeExtrudedGeometries(e,t){e.boundingBox.includeAABB(t.boundingBox),e.positionBuffer=V.mergeTypedArrays(Float32Array,[e.positionBuffer,t.positionBuffer]),e.uvBuffer=V.mergeTypedArrays(Float32Array,[e.uvBuffer,t.uvBuffer]),e.normalBuffer=V.mergeTypedArrays(Float32Array,[e.normalBuffer,t.normalBuffer]),e.textureIdBuffer=V.mergeTypedArrays(Uint8Array,[e.textureIdBuffer,t.textureIdBuffer]),e.colorBuffer=V.mergeTypedArrays(Uint8Array,[e.colorBuffer,t.colorBuffer])}static getExtrudedBuffers(e){this.mergeExtrudedGeometriesWithSameOsmRef(e);const t=[],n=[],r=[],s=[],i=[];for(const y of e)t.push(y.positionBuffer),n.push(y.uvBuffer),r.push(y.normalBuffer),s.push(y.textureIdBuffer),i.push(y.colorBuffer);const a=V.mergeTypedArrays(Float32Array,t),l=V.mergeTypedArrays(Float32Array,n),c=V.mergeTypedArrays(Float32Array,r),d=V.mergeTypedArrays(Uint8Array,s),h=V.mergeTypedArrays(Uint8Array,i),f=new Uint32Array(e.length),p=new Uint32Array(e.length*2),g=[];let m=0;for(let y=0;y<e.length;y++){const M=e[y],S=M.positionBuffer.length/3;p[y*2]=M.idBuffer[0],p[y*2+1]=M.idBuffer[1],f[y]=m,m+=S,g.push(V.fillTypedArraySequence(new Uint32Array(S),new Uint32Array([y])))}const x=V.mergeTypedArrays(Uint32Array,g);return{positionBuffer:a,uvBuffer:l,normalBuffer:c,textureIdBuffer:d,colorBuffer:h,idBuffer:p,offsetBuffer:f,localIdBuffer:x,boundingBox:this.boundingBoxToFlatObject(this.joinBoundingBoxes(e))}}static getProjectedBuffers(e){const t=this.sortProjectedFeatures(e),n=this.joinBoundingBoxes(t);n.min.y=-1e3,n.max.y=1e5;const r=[],s=[],i=[],a=[];for(const f of t)r.push(f.positionBuffer),s.push(f.uvBuffer),i.push(f.normalBuffer),a.push(f.textureIdBuffer);const l=V.mergeTypedArrays(Float32Array,r),c=V.mergeTypedArrays(Float32Array,s),d=V.mergeTypedArrays(Float32Array,i),h=V.mergeTypedArrays(Uint8Array,a);return{positionBuffer:l,normalBuffer:d,uvBuffer:c,textureIdBuffer:h,boundingBox:this.boundingBoxToFlatObject(n)}}static getHuggingBuffers(e){const t=this.joinBoundingBoxes(e);t.min.y=-1e3,t.max.y=1e5;const n=[],r=[],s=[],i=[];for(const h of e)n.push(h.positionBuffer),r.push(h.uvBuffer),s.push(h.normalBuffer),i.push(h.textureIdBuffer);const a=V.mergeTypedArrays(Float32Array,n),l=V.mergeTypedArrays(Float32Array,r),c=V.mergeTypedArrays(Float32Array,s),d=V.mergeTypedArrays(Uint8Array,i);return{positionBuffer:a,normalBuffer:c,uvBuffer:l,textureIdBuffer:d,boundingBox:this.boundingBoxToFlatObject(t)}}static getTerrainMaskBuffers(e,t){const n=4007501668e-2/(1<<t),r=[];for(const i of e)r.push(i.positionBuffer);const s=V.mergeTypedArrays(Float32Array,r);for(let i=0;i<s.length;i+=1)s[i]/=n;return{positionBuffer:s}}static getLabelsBuffers(e){const t=[],n=[],r=[],s=new $;for(const i of e){const a=new w(i.position[0],i.position[1],i.position[2]);t.push(a.x,a.y,a.z),n.push(i.priority),r.push(i.text),s.includePoint(a)}return{position:new Float32Array(t),priority:new Float32Array(n),text:r,boundingBox:this.boundingBoxToFlatObject(s)}}static getInstanceBuffers(e){const t=new Map;for(const r of e)t.has(r.instanceType)||t.set(r.instanceType,[]),t.get(r.instanceType).push(r);const n={};for(const[r,s]of t.entries()){const i=hs[r],a=Ze.getInstancesBuffers(s,i);n[r]={interleavedBufferLOD0:a[0],interleavedBufferLOD1:a[1]}}return n}static getInstancesBuffers(e,t){const n=t.LOD1Fraction>0?this.clearInstancesWithHeatMap(e,12,t.LOD1Fraction):[];return[this.createInstanceInterleavedBuffer(e,t),this.createInstanceInterleavedBuffer(n,t)]}static clearInstancesWithHeatMap(e,t,n){const r=611.4962158203125,s=new Array(t**2).fill(null).map(()=>[]);for(const a of e){const l=a.x/r*t,c=a.z/r*t,d=Math.floor(l)+Math.floor(c)*t;s[d].push(a)}const i=[];for(const a of s){if(a.length===0)continue;const l=Math.max(Math.round(a.length*n),1);i.push(...fs(a,l))}return i}static createInstanceInterleavedBuffer(e,t){const n=ds[t.structure],r=new Float32Array(e.length*n.componentsPerInstance);for(let s=0;s<e.length;s++){const i=e[s],a=n.getComponents(i);for(let l=0;l<n.componentsPerInstance;l++)r[s*n.componentsPerInstance+l]=a[l]}return r}static joinBoundingBoxes(e){const t=new $;for(const n of e)t.includeAABB(n.boundingBox);return t}static sortProjectedFeatures(e){return e.sort((t,n)=>t.zIndex-n.zIndex)}static boundingBoxToFlatObject(e){return{minX:e.min.x,minY:e.min.y,minZ:e.min.z,maxX:e.max.x,maxY:e.max.y,maxZ:e.max.z}}}var pe;(o=>{let e;(n=>{n[n.Start=0]="Start",n[n.Height=1]="Height"})(e=o.ToWorkerType||(o.ToWorkerType={}));let t;(n=>{n[n.Success=0]="Success",n[n.Error=1]="Error",n[n.RequestHeight=2]="RequestHeight"})(t=o.FromWorkerType||(o.FromWorkerType={}))})(pe||(pe={}));const Qe=self,Ke=class{constructor(o){this.ctx=o,this.requestTerrainHeight=!0,this.straightSkeletonReady=!1,this.addEventListeners()}addEventListeners(){Qe.addEventListener("message",async o=>{this.straightSkeletonReady||(await zt.SkeletonBuilder.init(),this.straightSkeletonReady=!0);const e=o.data,t=e.tile[0],n=e.tile[1];e.type===pe.ToWorkerType.Start&&(this.requestTerrainHeight=e.isTerrainHeightEnabled,this.fetchTile(t,n,e.overpassEndpoint,e.tileServerEndpoint,e.vectorTilesEndpointTemplate))})}fetchTile(o,e,t,n,r){new ue({overpassEndpoint:t,tileServerEndpoint:n,vectorTilesEndpointTemplate:r,heightPromise:a=>this.getTerrainHeight(o,e,a)}).getCollection({x:o,y:e,zoom:Ke.TileZoom}).then(a=>{const l=Ze.convert(a);this.sendBuffers(o,e,l)}).catch(a=>{console.error(a),this.sendError(o,e,a)})}sendMessage(o,e=[]){this.ctx.postMessage(o,e)}sendBuffers(o,e,t){this.sendMessage({type:pe.FromWorkerType.Success,tile:[o,e],payload:t},Ir(t))}sendError(o,e,t){this.sendMessage({type:pe.FromWorkerType.Error,tile:[o,e],payload:t})}sendHeightRequest(o,e,t){this.sendMessage({type:pe.FromWorkerType.RequestHeight,tile:[o,e],payload:t},[t.buffer])}async getTerrainHeight(o,e,t){return new Promise(n=>{if(!this.requestTerrainHeight){const s=new Float64Array(t.length/2);for(let i=0;i<s.length;i++)s[i]=0;n(s)}const r=async s=>{const i=s.data;o!==i.tile[0]||e!==i.tile[1]||i.type!==pe.ToWorkerType.Height||(Qe.removeEventListener("message",r),n(i.height))};Qe.addEventListener("message",r),Ke.applyTileOffsetToHeightPositions(t,o,e),this.sendHeightRequest(o,e,t)})}static applyTileOffsetToHeightPositions(o,e,t){const n=I.tile2meters(e,t+1,this.TileZoom);for(let r=0;r<o.length;r+=2)o[r]+=n.x,o[r+1]+=n.y}};let Kt=Ke;Kt.TileZoom=16,new Kt(self)},53434:(A,H)=>{var k=H.n={};k.read=function(v,T){return v.readFields(k._readField,{layers:[]},T)},k._readField=function(v,T,P){v===3&&T.layers.push(k.Layer.read(P,P.readVarint()+P.pos))},k.write=function(v,T){if(v.layers)for(var P=0;P<v.layers.length;P++)T.writeMessage(3,k.Layer.write,v.layers[P])},k.GeomType={UNKNOWN:{value:0,options:{}},POINT:{value:1,options:{}},LINESTRING:{value:2,options:{}},POLYGON:{value:3,options:{}}},k.Value={},k.Value.read=function(v,T){return v.readFields(k.Value._readField,{string_value:"",float_value:0,double_value:0,int_value:0,uint_value:0,sint_value:0,bool_value:!1},T)},k.Value._readField=function(v,T,P){v===1?T.string_value=P.readString():v===2?T.float_value=P.readFloat():v===3?T.double_value=P.readDouble():v===4?T.int_value=P.readVarint(!0):v===5?T.uint_value=P.readVarint():v===6?T.sint_value=P.readSVarint():v===7&&(T.bool_value=P.readBoolean())},k.Value.write=function(v,T){v.string_value&&T.writeStringField(1,v.string_value),v.float_value&&T.writeFloatField(2,v.float_value),v.double_value&&T.writeDoubleField(3,v.double_value),v.int_value&&T.writeVarintField(4,v.int_value),v.uint_value&&T.writeVarintField(5,v.uint_value),v.sint_value&&T.writeSVarintField(6,v.sint_value),v.bool_value&&T.writeBooleanField(7,v.bool_value)},k.Feature={},k.Feature.read=function(v,T){return v.readFields(k.Feature._readField,{id:0,tags:[],type:0,geometry:[]},T)},k.Feature._readField=function(v,T,P){v===1?T.id=P.readVarint():v===2?P.readPackedVarint(T.tags):v===3?T.type=P.readVarint():v===4&&P.readPackedVarint(T.geometry)},k.Feature.write=function(v,T){v.id&&T.writeVarintField(1,v.id),v.tags&&T.writePackedVarint(2,v.tags),v.type&&T.writeVarintField(3,v.type),v.geometry&&T.writePackedVarint(4,v.geometry)},k.Layer={},k.Layer.read=function(v,T){return v.readFields(k.Layer._readField,{version:0,name:"",features:[],keys:[],values:[],extent:0},T)},k.Layer._readField=function(v,T,P){v===15?T.version=P.readVarint():v===1?T.name=P.readString():v===2?T.features.push(k.Feature.read(P,P.readVarint()+P.pos)):v===3?T.keys.push(P.readString()):v===4?T.values.push(k.Value.read(P,P.readVarint()+P.pos)):v===5&&(T.extent=P.readVarint())},k.Layer.write=function(v,T){if(v.version&&T.writeVarintField(15,v.version),v.name&&T.writeStringField(1,v.name),v.features)for(var P=0;P<v.features.length;P++)T.writeMessage(2,k.Feature.write,v.features[P]);if(v.keys)for(P=0;P<v.keys.length;P++)T.writeStringField(3,v.keys[P]);if(v.values)for(P=0;P<v.values.length;P++)T.writeMessage(4,k.Value.write,v.values[P]);v.extent&&T.writeVarintField(5,v.extent)}}},nt={};function C(A){var H=nt[A];if(H!==void 0)return H.exports;var k=nt[A]={exports:{}};return tt[A].call(k.exports,k,k.exports,C),k.exports}C.m=tt,C.x=()=>{var A=C.O(void 0,[504],()=>C(1674));return A=C.O(A),A},(()=>{var A=[];C.O=(H,k,v,T)=>{if(k){T=T||0;for(var P=A.length;P>0&&A[P-1][2]>T;P--)A[P]=A[P-1];A[P]=[k,v,T];return}for(var U=1/0,P=0;P<A.length;P++){for(var[k,v,T]=A[P],W=!0,q=0;q<k.length;q++)(T&!1||U>=T)&&Object.keys(C.O).every(Ne=>C.O[Ne](k[q]))?k.splice(q--,1):(W=!1,T<U&&(U=T));if(W){A.splice(P--,1);var de=v();de!==void 0&&(H=de)}}return H}})(),C.n=A=>{var H=A&&A.__esModule?()=>A.default:()=>A;return C.d(H,{a:H}),H},C.d=(A,H)=>{for(var k in H)C.o(H,k)&&!C.o(A,k)&&Object.defineProperty(A,k,{enumerable:!0,get:H[k]})},C.f={},C.e=A=>Promise.all(Object.keys(C.f).reduce((H,k)=>(C.f[k](A,H),H),[])),C.u=A=>"./js/index.db0e485d12ee185ff169.js",C.miniCssF=A=>{},C.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),C.o=(A,H)=>Object.prototype.hasOwnProperty.call(A,H),C.r=A=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},(()=>{var A;C.g.importScripts&&(A=C.g.location+"");var H=C.g.document;if(!A&&H&&(H.currentScript&&(A=H.currentScript.src),!A)){var k=H.getElementsByTagName("script");k.length&&(A=k[k.length-1].src)}if(!A)throw new Error("Automatic publicPath is not supported in this browser");A=A.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),C.p=A+"../"})(),(()=>{var A={674:1},H=T=>{var[P,U,W]=T;for(var q in U)C.o(U,q)&&(C.m[q]=U[q]);for(W&&W(C);P.length;)A[P.pop()]=1;v(T)};C.f.i=(T,P)=>{A[T]||importScripts(C.p+C.u(T))};var k=self.webpackChunkstreets_gl=self.webpackChunkstreets_gl||[],v=k.push.bind(k);k.push=H})(),(()=>{var A=C.x;C.x=()=>C.e(504).then(A)})();var gs=C.x()})();})();
